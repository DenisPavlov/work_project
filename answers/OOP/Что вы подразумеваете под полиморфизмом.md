## Что Вы подразумеваете под полиморфизмом, инкапсуляцией и динамическим связыванием?

Полиморфизм означает способность  переменной данного типа, которая  ссылается на объекты разных  типов, при этом вызывается  метод, характерный для конкретного  типа ссылки на объект.

В чем преимущество полиморфизма? Он позволяет добавлять новые классы производных объектов, не нарушая  при этом код вызова. Также использование полиморфизма называют динамическим связыванием объектов.

Рассмотрим пример полиморфизма:
Имеются классы : фигура, круг, треугольник
```java
public class Figure {
    public void draw(){
        System.out.println("Рисуем фигуру");
    }
}

public class Circle extends Figure {
    @Override
    public void draw() {
        System.out.println("Рисуем круг");
    }
}
```
Круг наследуется от фигуры. Классы имеют метод "рисовать". В круге этот метод переопределен.

Так вот, создадим объект с типом фигура и присвоем ей ссылку на объект типа круг и вызовем метод "рисовать". 
```java
package answers.OOP.polimorfism;

public class Main {
    public static void main(String[] args) {
        Figure circle = new Circle();
        circle.draw();
    }

    public static void drawShape(Figure figure){
        figure.draw();
    }
}
```
Вызовется метод класса круг. На консоль выведет - "Рисуем круг".

Также вместо класса родителя "фигура" к примеру, можно использовать интерфейс  методом "рисовать".

```java
package answers.OOP.polimorfism;

public interface Drawing {
    void draw();
}
```
Этот интерфейс мы имплементируем у класса "треугодник". Далее на интерфейчсе создадим оъект и присвоем ему ссылку на объект какого-то из реализующих этот интерфейс классов

Это удобна например если у нас есть некий метод:
```java
package answers.OOP.polimorfism;

public class Triangle extends Figure implements Drawing {
    //ошибки нет т.к интерфейс реализован в классе родителе
}
public class Main {
    public static void main(String[] args) {
        Drawing drawing = new Triangle();
        drawing.draw();
    }
    public static void drawShape(Drawing drawing){
        drawing.draw();
    }
}
```
Обратите внимание, что в метод мы передаем параметр с типом интерфейса, т.е. мы не знаем какой именно объект отрабатывать.

Наследование  это включение поведения(методы) и состояния(поля) базового класса в производный от него.
В результате этого мы избегаем дублирования кода и процесс исправления ошибок в коде также упрощается.

В джава есть два вида наследования:
- наследование классов. Каждый  наследник может иметь толко одного родителя.
- наследование  интерфейсов. Интерфейс может  иметь сколько угодно родителей.

Некоторые тонкие ньюансы по поводу наследования интрефейсов и классов.
- Мы  имеем два интерфейса с одинаковыми  по имени полями. Имплементируем эти  интерфейсы на каком-то классе.
Как нам вызвать поля этих интерфейсов.  
```java
package answers.OOP.polimorfism;
public interface Drawing {
    String COLOR = "black";
    void draw();
}
public interface Drawing1 {
    String COLOR = "red";
}
public class Triangle extends Figure implements Drawing, Drawing1 {
    //ошибки нет т.к интерфейс реализован в классе родителе
}
```
У нас неоднозначность. Необходимо объект класса привести к нужному интерфейсу.
```java
public class Main {
    public static void main(String[] args) {
        Triangle triangle = new Triangle();
        System.out.println(((Drawing)triangle).COLOR);
    }
}
```
- Хорошо, что будет если мы имеем метод с одинаковой сигнатурой в интерфейсах и реализуем эти интерфейсы на классе. Как нам в классе реализовать два метода с одинаковой сигнатурой???

Ответ: никак, мы просто реализовываем один общий метод в классе. Это является недостатком, так как нам  может потребоваться разная реализация.

- И третий случай: У нас есть класс  и интерфейс с одинаковым по сигнатуре  методом. Мы наследуемся от этого  класса и имплементируем этот интерфейс. Что нам нужно делать? ведь необходимо реализовать метод интерфейса по всем правилам.

И вот тут интересно, компилятор не выдает ошибок, так как метод уже  у нас реализован в классе родителе.
