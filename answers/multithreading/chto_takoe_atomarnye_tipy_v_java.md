Все атомарные классы переменных имеют базовый элемент - Сравнение и назначение (compare-and-set) (аналогичный элементу Сравнение и замена), который реализуется при помощи самого быстрого собственного структурного компонента, кооторый имеется в платформе (Сравнение и замена, Загрузить в связке, Сохранить при условии или в крайнем случае спин-блокировками).
В пакет java.util.concurrent.atomic входят 9 видов атомарных переменных (AtomicInteger; AtomicLong; AtomicReference; AtomicBoolean; формы для массивов атомарных целых чисел; длинные (long); ссылки; а также атомарные с пометкой Класс эталона (reference), которые атомарно обновляют две величины).

Классы атомарных переменных можно рассматривать как обобщение volatile переменных, если расширить понятие изменяемых переменных до переменных с поддержкой атомарных обновлений методом Сравнение и назначение.
Чтение и запись атомарных переменных имеет такую же семантику памяти как доступ к чтению и записи изменяемых переменных.

Пример атомарной переменной AtomicLong:

```java
private volatile long value;
 
public final long get() {
    return value;
}
 
public final long getAndAdd(long delta) {
    while (true) {
        long current = get();
        long next = current + delta;
        if (compareAndSet(current, next))
            return current;
    }
}
```
Переменные current и next — локальные, а следовательно у каждого потока свои экземпляры этих переменных.
Следует обратить внимание лишь на разделяемое состояние, т.е. переменную value.
Т.к. переменная value объявлена с модификатором volatile, то гарантируется выполнение отношения happens-before, что ведет к тому, что измененное значение этой переменной увидят все потоки.

Метод <code>compareAndSet</code> представляет из себя механизм оптимистичной блокировки и позволяет изменить значение value, только если оно равно ожидаемому значению (т.е. current).

Если же значение value было изменено в другом потоке, то оно не будет равно ожидаемому значению.
Следовательно метод <code>compareAndSet</code> вернет значение false, что приведет к новой итерации цикла <code>while</code> в методе <code>getAndAdd()</code>.
Т.е. новое значение value будет перезачитано в переменную current, после чего будет произведено сложение и новая попытка записи получившегося значения (т.е. next).
