Статические методы могут перегружаться нестатическими и наоборот - без ограничений. А вот в переопределении статического метода смысла нет.

На вопрос "может ли статический метод быть переопределен?" - ответ "НЕТ"! Статические методы не переопределяются!

Перегружен - да. 
Всё работает точно так же как и с обычными методами (2 статичных метода могут иметь одинаковое имя если кол-во аргументов ИЛИ их типы отличаются).
Переопределён - официальный ответ: нет. Т.к. переопределение подразумевает выполнение метода Б при вызове метода А, если Б переопределяет А.
Статичный вызов точно определяет, какой именно метод будет выполнен.
Но! Джава позволяет вызывать статичный метод класса А на экземпляре класса А, или на любом наследованном от него классе и его экземпляре.
Такое поведение вызывает больше проблем, чем пользы, и создаёт видимость переопределения статичных методов.
Пример: 
1. Класс A объявляет метод "public static void some()"
```java
public class A {
    public static void some() {
        System.out.println("some A");
    }
}
```
 
2. Класс B наследован от А 
```java
public class B extends A {
}
```
3. Класс C наследован от B

```java
public class C extends B {
}
```
Вызов метода "C.some()" выполнит метод из класса А.
```java
    public static void main(String[] args) {
        C.some();
    }
```
Выведет на экран - <code>some A</code>.


Но если класс B объявит точно такой же метод "public static void some()", то вызов "C.some()" выполнит метод из класса B.

Такое поведение называется "сокрытием" и работает по ТОЧНО таким же правилам, как и переопределение - одинаковая сигнатура, такой же или более широкий доступ и такие же или более узкие исключения и возвращаемое значение.
Т.е. (!) при написании статичного переопределяющего метода нужно придерживаться точно таки же ограничений, как и с обычным методом, но он не будет участвовать в полиморфизме - если ваш метод принимает параметр "A a" и вызывает на полученном объекте статичный метод "a.some()" то всегда будет вызван именно метод класса A, даже если передан был объект класса B или C.
Именно поэтому возможность вызова статичных методов на экземплярах считается вредоносной и повсеместно осуждается на практике.