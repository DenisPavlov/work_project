1) Используйте оператор == что бы проверить ссылку на объект, переданную в метод equals. Если ссылки совпадают - вернуть true. Это не обязательно, нужно скорее для оптимизации, но может сэкономить время в случае "тяжёлых" сравнений.
2) Используйте оператор <code>instanceof</code> для проверки типа аргумента. Если типы не совпадают, вернуть false.
3) Преобразуйте аргумент к корректному типу. Так как на предыдущем шаге мы выполнили проверку, преобразование корректно.
4) Пройтись по всем значимым полям объектов и сравнить их друг с другом. Если все поля равны - вернуть <code>true</code>. Для сравнения простых типов использовать ==. Для полей со ссылкой на объекты использовать <code>equals</code>. <code>float</code> преобразовывать в <code>int</code> с помощью <code>Float.floatToIntBits</code> и сравнить с помощью ==. <code>double</code> преобразовывать в <code>long</code> с помощью </code>Double.doubleToLongBits</code> и сравнить с помощью ==. Для коллекций вышеперечисленные правила применяются к каждому элементу коллекции. Нужно учитывать возможность <code>null</code> полей/объектов. Очерёдность сравнения полей может существенно влиять на производительность.
5) Закончив реализацию equals задайте себе вопрос, является ли метод симметричным, транзитивным и непротиворечивым.

И ещё несколько дополнительных правил.
1) Переопределив <code>equals</code>, всегда переопределять <code>hashCode</code>.
2) Не использовать сложную семантику в <code>equals</code> (типа определения синонимов). <code>equals</code> должен сравнивать поля объектов, не более.
