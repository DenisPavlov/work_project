<code></code>

#### Теория
- Все операции в scala являются вызовами методов
- оператор cons - ::
- если имя метода заканчивается двоеточием (:), то метод вызывается у правого операнда (a:::b преобразуется в b.:::(a))
- Nil - пустая коллекция (например для инициализации List)
- в отсутствии явного слова return метод в scala возвращает последнее вычисляемое им значение
- <b>процедура</b> - метод который выполняется только для получения побочного эффекта
- класс и объект спутники могут обращаться к закрытым элементам друг друга
- синглтон объект вызывается так: имя синглтон-объекта точка имя метода (как статический класс в Java)
- <b>автономный объект</b> - синглтон объект без спутника
- по умолчанию импортируется синглтон-объект <b>Predef</b>
- <code>import org.apache.http.{HttpEntity, HttpResponse}</code> - импорт нескольких классов из одного пакета
- <code>import org.apache.http._</code> - импорт всех классов пакета
- <code>import java.sql.{Date => SQLDate}</code> - импорт класса <code>Date</code> и присваивание ему нового имени (позволяет импортировать классы с одинаковыми именами)
- Имя, список параметров и возвращаемый тип, если он указан, образуют сигнатуру метода.
- если метод не принимает параметров то его можно вызвать без скобок
- функциональные объекты - те у которых нет изменяемого состояния
- в классе, если инструкция не принадлежит методу или полю, значит она принадлежит первичному конструктору
- функции – это конструкции первого класса
- параметризация - конфигурирование экземпляра в той точке программы, где он создается.
- параметризация типом и значением - <code>val greetStrings = new Array\[String\](3)</code>
- если метод принимает только один параметр, его можно вызывать без точки и скобок
- Когда вы применяете круглые скобки к переменной или значению и помещаете внутрь какие-то аргументы, Scala трансформирует их в вызов метода <code>apply</code>.
- когда присвоение выполняется для значения или переменной, за которой идут какие-то аргументы в скобках, компилятор трансформирует их в вызов метода <code>update</code>, принимающего два параметра. Например:
  <code>greetStrings(0) = "Hello"</code> трансформируется в <code>greetStrings.update(0, "Hello")</code>


#### Типы данных

##### Unit
- Unit - аналог типа void в java
- Главная разница между <code>Unit</code> в Scala и <code>void</code> в Java состоит в том, что Scala позволяет записать значение типа <code>Unit</code>, а именно (), а в Java нет значений типа <code>void</code>.

#### Работа со строками
- строковая интерполяция - s"Hello $name!", если переменная name = "Denis", то получится строка "Hello Denis". Интерполятор s подставляет метод name.toString.
- можно сделать такую интерполяцию - s"Ответ равен ${6 * 7}"  и получится строка "Ответ равен 42"
- строковый интерполятор <b>raw</b> ведет себя практически также как и <b>s</b>, только не распознает управляющие последоватьности символьных литератлов
  например raw"No\\\\escape" выведет "No\\\\escape" а не "No\\escape"  
- строковый интерполятор <b>f</b> позволяет прикреплять к встроенным выражениям инструкции форматирования в стиле функции <code>printf</code> (синтаксис <code>java.util.Formatter</code>)
  например f"${Math.PI}%.5f" выведет "3.14159" (5 знаков после запятой)


#### Операторы (по факту методы)
- метод -> возвращает картеж (ключб значение)

#### Структуры данных

##### Кортеж (Tuples)
- структура данных которая объединяет несколько элементов (элементы могут быть разных типов)
- количество элементов - до 22 элементов, включительно
- создание: <code>val имя_коллекции = ("Some String", 100500, "#FFFFFF")</code>
- получение элемента: через <code>кортеж._№</code>, где № - номер элемента (начинается с 1)
- получение элемента: <code>val integerTupleSum = integerTuple._1 + integerTuple._2 + integerTuple._3</code>

##### Массив (Array)
- создание массива - <code>val greetStrings = new Array\[String\](3)</code>
- инициализация массива - <code>greetStrings(0) = "Hello"</code>
- доступ к элементу массива - <code>greetStrings(0)</code>

##### List
- имутабилен (не изменен)
- создание листа - <code>val oneTwoThree = List(1, 2, 3)</code>
- <code>:::</code> - метод конкатенирует переданный список и список, для которого был вызван <code>:::</code>
- пример:
````scala
val oneTwo = List(1, 2)
val threeFour = List(3, 4)
val oneTwoThreeFour = oneTwo ::: threeFour
````
- <code>::</code> - присоединяет новый элемент к началу существующего списка и возвращает получившийся лист
- инициализация List - val oneTwoThree = 1 :: 2 :: 3 :: Nil
- некоторые методы

First Header | Second Header
------------ | -------------
List() | создает пустой список
List("Cool", "tools", "rule") | Создает новый List\[String\] с тремя значениями "Cool", "tools" и "rule"
val thrill = "Will" :: "fill" :: "until" :: Nil | Создает новый List\[String\] с тремя значениями "Will", "fill" и "until"
thrill(2) | Возвращает второй (с отсчетом с нуля) элемент списка thrill (возвращает "until").
thrill.count(s => s.length == 4) | Возвращает число элементов thrill, длина которых равна 4 (возвращает 2).
thrill.drop(2) | Возвращает список thrill без первых двух элементов (возвращает List("until")).
thrill.dropRight(2) | Возвращает список thrill без двух правых элементов (возвращает List("Will ")).
thrill.exists(s => s == "until") | Определяет, есть ли в thrill элемент со значением "until" (возвращает true).
thrill.filter(s => s.length == 4) | Возвращает список, состоящий из элементов списка thrill List , длина которых равна 4 (возвращает List("Will", "fill"))
thrill.forall(s => s.endsWith("l")) | Возвращает true, если все ли элементы списка thrill заканчиваются на букву "l", и false в обратном случае (в данном примере возвращает true).
thrill.foreach(s => print(s)) | Исполняет выражение print для каждого элемента списка thrill (выводит "Willfilluntil").
thrill.foreach(print) | То же, что предыдущее, но короче (тоже выводит "Willfilluntil").
thrill.head | Возвращает первый элемент списка thrill (возвращает "Will").
thrill.init | Возвращает список, состоящий из всех, кроме последнего, элементов списка thrill (возвращает List("Will", "fill")).
thrill.isEmpty | Отвечает на вопрос, является ли список thrill пустым (возвращает false)
thrill.last | Возвращает последний элемент списка thrill ("until")
thrill.length | Возвращает число элементов списка thrill (возвращает 3).
thrill.map(s => s + "y") | Возвращает список, образующийся при добавлении "y" к каждому из элементов списка thrill. То есть как бы отображает (map) один список на другой (возвращает List("Willy", "filly", "untily")).
thrill.remove(s => s.length == 4) | Возвращает копию списка thrill, из которой удалены все элементы, длина которых равна 4 (возвращает List("until")).
thrill.reverse | Возвращает List, содержащий все элементы thrill List в обратном порядке (возвращает List("fill", "until", "Will")).
thrill.sort((s, t) => s.charAt(0).toLowerCase < t.charAt(0).toLowerCase) | Возвращает отсортированную копию списка thrill (возвращает List("fill", "until", "Will")).
thrill.tail | Возвращает список thrill за вычетом его первого элемента (возвращает List("fill", "until")).

#### Рекомендации по стилю
- Если метод может иметь побочные эффекты (говорят, что метод имеет побочный эффект, если он изменяет состояние 
  за пределами метода), скобки нужно указывать независимо от того, требует ли их компилятор.
- 

#### Predef
- require(par: Boolean) - метод для проверки значений. Если приходит false, то будет выброшен <code>java.lang.IllegalArgumentException</code>


#### Функциональное программирование
- foreach - <code>args.foreach(arg => println(arg))</code> (для args вызывается метод foreach, которому передается функция). В данном случае вы передаете анонимную функцию (не имеющую имени), принимающую один параметр arg. Код анонимной функции – <code>println(arg)</code>.
- эквивалент предыдущей функции - <code>args.foreach(println)</code> или <code>args.foreach(arg: String => println(arg))</code>
- ![Logo](1.png)
- for comprehension - <code>for (arg <- args) println(arg)</code>. Слева от символа <code><-</code>, который можно назвать "в",
  находится декларация нового значения (не переменной) <code>arg</code>. Справа от <code><-</code> находится знакомый массив <code>args</code>.
  При выполнении этого кода значение arg будет сопоставлено по очереди с каждым элементом массива <code>args</code>, и для каждого значения 
  будет выполнено тело <code>for</code>, <code>println(arg)</code>.
- for comprehension - <code>for (i <- 0 to 2) print(greetStrings(i))</code>. <code>to</code> на самом деле метод, определенный в классе <code>scala.Int</code>, и принимающий один аргумент, также типа <code>int</code>. Код <code>0 to 2</code> трансформируется в вызов метода <code>0.to(2)<code>
- 