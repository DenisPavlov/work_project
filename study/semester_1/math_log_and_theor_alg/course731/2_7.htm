<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<style>
P {text-align=justify;
		text-indent= 19px;
		}</style>
<TITLE>Математическая логика и теория алгоритмов</TITLE>
</HEAD>
<BODY >
<BASEFONT face=arial> 
<table border= 0  cellpadding= 0  cellspacing= 0  width= 100%
  height= 31 >
    <tr>
        <td width= 100%  bgcolor=#000000>
         <div align= right><font color= #FFFFFF  size= 3  face= Arial><b>Математическая логика и теория алгоритмов</b></font>
         </div>
        </td>
    </tr>
</table>

<table border= 0  cellpadding= 0  cellspacing= 0  height= 35 >
    <tr>
        <td width=400  bgcolor=gray><p align= right><font   color= #FFFFFF size=3  face= Arial><strong> 
		<B>2.7 Характеристики сложности алгоритмов</B> </strong></font></p>
        </td>

          <td width= 300  bgcolor= #EEE0BF >
		  
	      <p align= center > <a href= 2_6.htm> <font color= #0000FF  size= 2  face= Arial>назад</font></a> <font
              color= #0000FF  size= 2  face= Arial> | </font> <a href= main.htm><font color= #0000FF  size= 2 
          face= Arial>оглавление</font></a> <font color= #0000FF  size= 2  face= Arial> 
        | </font> <a href= 2_8.htm> <font color= #0000FF  size= 2  face= Arial>вперёд</font> 
        </a> <font color= #0000FF  size= 2  face= Arial> </font></p>
        </td>
        <td width= 260  height= 35 >&nbsp;</td>
    </tr>
</table>
<P>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspРазличные подходы к уточнению понятия <a href="2_1.htm#alg">«алгоритм»</a> позволяли изучать принципиальную возможность решения некоторой математической задачи. (Здесь речь идет об общих задачах, в которых исходные данные могут варьироваться). Однако теоретическая возможность алгоритмического решения задачи еще не гарантирует практическую реализуемость алгоритма. Поэтому необходимо ввести характеристики алгоритмов, которые бы показывали степень  практической реализуемости  алгоритмов. Другая причина, по которой необходимы такие характеристики, – необходимость сравнения эффективности различных алгоритмов, которые решают одну и ту же задачу.
<P>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspПри решении некоторой задачи P алгоритмом  A обычно рассматривают такие характеристики:
<ul>
    <li>количество шагов <i>T<sub>A</sub>(x)</i>, которое необходимо сделать алгоритму A  для получения результата при использовании входных данных x. Величина <img src=img/2_7.gif align="absmiddle">  (максимум берется по всем входным данным объема n) называется <i>временной сложностью</i> алгоритма A.
    <li>объем памяти <i>M<sub>A</sub>(x)</i>, необходимый для хранения всех входных и промежуточных данных в процессе выполнения алгоритма при использовании входных данных x. Величина <img src=img/2_7_1.gif align="absmiddle">  (максимум берется по всем входным данным объема n) называется <i>емкостной сложностью</i> алгоритма A.
</ul>
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspДля определения временной сложности алгоритма вместо общего числа шагов алгоритма можно также использовать количество операций определенного вида. Аналогично можно определить <i>средние</i> величины временной и емкостной сложности  алгоритма. Сложность задачи P – это сложность наилучшего алгоритма, известного для ее решения, т.е. <img src=img/2_7_2.gif align="absmiddle">  (минимум берется по всем алгоритмам для задачи P).
<P>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspВведем понятие <i>верхнего и нижнего порядка функции</i> относительно другой функции. Назовем арифметическую функцию <i>f(x)</i>  функцией <i>одного верхнего порядка</i> с функцией <i>g(x)</i>, т.е. <i>f(x)=O(g(x))</i>, если существует такая натуральная константа  C  и некоторое натуральное <i>N<sub>0</sub></i>, что <img src=img/2_7_3.gif align="absmiddle">  для всех <i>x &#8805 N<sub>0</sub></i>.
<P>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspНазовем арифметическую функцию <i>f(x)</i> функцией <i>одного нижнего порядка</i> с функцией <i>g(x)</i>, т.е. <i>f(x)=&#937(g(x))</i>, если существует такая натуральная константа C  и некоторое натуральное <i>N<sub>0</sub></i>, что <img src=img/2_7_4.gif align="absmiddle">  для всех <i>x &#8805 N<sub>0</sub></i>. 
<P>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspАрифметическая функция <i>f(x)</i>  – <i>функция одного порядка</i> с функцией <i>g(x)</i>, если она одного верхнего и одного нижнего порядка с функцией <i>g(x)</i>, т.е. <i>f(x)=O(g(x))</i> и <i>f(x)=&#937(g(x))</i>.
<br><br><b>Пример 1.</b>Пусть <i>f(x)=log x</i>  и <i>g(x)=x</i>. Tогда существует положительная константа C, что <i>log x &#8804 C*x</i> при <i>x &#8805 1</i> , т.е. <i>f(x)=O(g(x))</i>.
<P>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspФункция одного верхнего порядка с полиномиальными функциями называется <i>полиномиальной функцией</i>. Это не только все полиномы, но и некоторые трансцендентные функции. Все остальные функции есть экспоненциальные в широком смысле этого слова. Но в строгом смысле слова экспоненциальными называются функции одного нижнего порядка с экспонентой. Тогда функции между экспоненциальными и полиномиальными называются субэкспоненциальными функциями. Экспоненциальные функции выделяются по скорости еще на несколько классов.
<P>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspАрифметические функции <i>f(x)</i>  и  <i>g(x)</i> называются <i>полиномиально-связанными или полиномиально-эквивалентнтными</i>, если существуют такие многочлены <i>P<sub>1</sub>(x)</i>  и <i>P<sub>2</sub>(x)</i> и некоторое натуральное <i>N<sub>0</sub></i>, что <i>f(x) &#8804 P<sub>1</sub>(g(x))</i> и <i>g(x) &#8804 P<sub>2</sub>(f(x))</i>  для всех <i>x &#8805 N<sub>0</sub></i>.

<br><br><b>Пример 2.</b>Две функции <i>f(x)=2x
+3</i>  и  <i>g(x)=x<sup>3</sup></i> полиномиально связаны или эквивалентны, поскольку существуют два полинома <i>P<sub>1</sub>(x)=x</i>  и <i>P<sub>2</sub>(x)=x<sup>3</sup></i>  таких, что <i>f(x) &#8804 P<sub>1</sub>(g(x))=x<sup>3</sup></i>  и <i>g(x) &#8804 P<sub>2</sub>(f(x))=(2x+3)<sup>3</sup></i>.

<P>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspРассмотрим задачу сортировки массива из n  элементов. Хорошо известны алгоритмы решения этой задачи. В качестве временной сложности  алгоритма сортировки используют две характеристики – количество сравнений элементов <i>T<sub>1</sub></i>  и количество пересылок элементов <i>T<sub>2</sub></i>, необходимых  в ходе работы алгоритма. Для метода пузырьковой сортировки  показано, что <i>T<sub>1</sub>(n)=O(n<sup>2</sup>)</i> и <i>T<sub>2</sub>(n)=O(n<sup>2</sup>)</i>. Однако существуют алгоритмы, например алгоритм Хоара, который имеет лучшую верхнюю оценку временной сложности, чем метод пузырьковой сортировки. В частности, <i>T<sub>1</sub>(n)=O(n log n)</i>  и <i>T<sub>2</sub>(n)=O(n log n)</i>. Для задачи сортировки доказана нижняя оценка временной сложности <i>T<sub>1</sub>(n) &#8805 C<sub>1</sub> * nlogn</i> и <i>T<sub>2</sub>(n) &#8805 C<sub>2</sub> * nlogn</i> при <img src=img/2_7_5.gif align="absmiddle">   или <i>T<sub>1</sub>(n)=&#937(nlogn)</i>, <i>T<sub>2</sub>(n)=&#937(nlogn)</i>, т.е.  для сортировки массива требуется как минимум <i>C * nlogn</i>  сравнений и пересылок. Таким образом, сложность задачи сортировки массива из n   элементов имеет порядок <i>nlogn</i> при  <img src=img/2_7_5.gif align="absmiddle">. 
<P>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspРассмотрим известный алгоритм сложения двух чисел столбиком. Входные данные – два числа, записанные в десятичной системе. Будем считать, что числа имеют n  десятичных цифр в своем представлении. В качестве временной сложности этого алгоритма будем использовать количество операций сложений цифр, которое требуется для получения результата. Максимальное число сложений получается в случае, когда происходит перенос разряда для каждой цифры, т.е. <i>T(n)=n + n + 1=2n + 1=O(n)</i>. Очевидно, что емкостная сложность <i>M(n)=O(n)</i>.
<P>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspОпределим сложность задачи сложения двух натуральных чисел при вычислении на <a href="2_2.htm#OMT">машине Тьюринга</a>. На вход МТ подаются две последовательности десятичных чисел. <a href="2_2.htm#vnamt">Внешний алфавит</a> такой МТ содержит десятичные цифры и  <a href="2_2.htm#pust">пустой символ</a>, т.е. <i>A={*,0,1,2,...,9}</i>, где * – пустой символ.
<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="2_2.htm#konf">Начальная конфигурация</a> выглядит так <i>*q<sub>1</sub>a<sub>n-1</sub>a<sub>n-2</sub>...a<sub>1</sub>*b<sub>n-1</sub>b<sub>n-2</sub>...b<sub>1</sub>**</i>. В общих чертах поведение МТ можно описать так. Сначала <a href="2_2.htm#ug">головка</a> перемещается к концу второй последовательности стирает младший разряд, затем перемещается к младшему разряду первого числа и заменяет его на сумму младших разрядов и т.д.
<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspВ качестве меры временной сложности данного алгоритма будем использовать количество выполненных команд МТ для перехода  из начальной конфигурации в заключительную, т.е. на ленте записан результат сложения в виде последовательности десятичных цифр и головка установлена на первой цифре. Емкостная сложность вычислений на МТ определяется количеством ячеек ленты, которые заполнены непустыми символами либо посещались головкой во время работы МТ.
<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspНе трудно подсчитать общее количество действий и задействованных ячеек, <i>T(n)=O(n<sup>2</sup>)</i>, <i>M(n)=O(n)</i>. При этом для получения одного разряда результата требуется порядка <i>n</i>  действий. Таким образом, временные сложности алгоритма сложения столбиком и алгоритма сложения на МТ полиномиально эквивалентны.

<br><br><b>Пример 3.</b>Арифметическая функция   <i>f(x,y)=x+y</i> является <a href="2_5.htm#prf">примитивно рекурсивной</a>, поскольку получена при помощи операции примитивной рекурсивной функции. 
<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspДействительно,
<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src=img/2_7_6.gif align="absmiddle">,
<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspгде <i>h(x,y,z)=S(U<sub>3</sub><sup>3</sup>(x,y,z))</i>. Поскольку функции <i>g</i>  и <i>h</i>  являются примитивно рекурсивными, то и функция <i>f</i>  является примитивно рекурсивной. Процесс получения функции <i>f</i>  можно представить графически в виде дерева
<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src=img/2_7_7.gif align=center> 
<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspВ качестве временной сложности можно использовать количество операций <a href="2_3.htm#prsup">суперпозиции</a>, <a href="2_5.htm#prf">примитивной рекурсии</a> и <a href="2_6.htm#omf">минимизации</a>, которые необходимы при получении функции. Количество вершин в дереве заменит емкостную сложность получения рекурсивной функции. В данном случае <i>T=2, M=5</i>.



<P>
<hr>
<div align= center >

<a href= 2_6.htm><font color= #0000FF  size= 2 face= Arial>назад</font></a>

<font color= #0000FF  size= 2 face= Arial> | </font>

<a href= main.htm><font color= #0000FF size= 2  face= Arial>оглавление</font></a>

<font color= #0000FF  size= 2  face= Arial> | </font>

<a href= 2_8.htm><font color= #0000FF  size= 2  face= Arial>вперёд</font></a>
<font color= #0000FF  size= 2  face= Arial> </font></div>
<br>
</body>
</html>
