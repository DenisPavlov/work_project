<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="do.sibsutis.ru">

  <title>Информатика</title>
	
	<link rel="icon" type="image/png" href="../lib/css/favicon.png">
  <!-- Bootstrap Core CSS -->
  <link href="../lib/css/bootstrap.css" rel="stylesheet">
	
  <!-- Custom CSS -->
  <link href="../lib/css/scrolling-nav.css" rel="stylesheet">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>

<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top" data-spy="scroll" data-target=".navbar-fixed-top">
  <!-- Navigation -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
  <!-- Brand and toggle get grouped for better mobile display -->
 
 <div class="navbar-header">
 
  <li class="hidden"> <a class="page-scroll" href="#page-top"></a> </li>
	 
	
 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
   </button>
	 
   <a class="navbar-brand " href="../index.html"> 
  <text class = "hidden-xs">Информатика</text> 
  <text class = "visible-xs">Информатика</text>
</a>
  </div>

 
 <!-- Collect the nav links, forms, and glyphicon glyphicon-list-alt content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
   
	  
 <ul class="nav navbar-nav navbar-right">
   
 <li class="dropdown">
		<button type="button" class="navbar-toggle dropdown-toggle hidden-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>	   
		<a class = "dropdown-toggle visible-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Материалы</a>
    
	<ul class="dropdown-menu">
	
		<li><a href="../index.html">Аннотация курса</a></li>
	
		<li role="separator" class="divider"></li>
	
		<li><a href="lec_index.html">Теория</a></li>
		<li><a href="labs.html">Лабораторные работы</a></li>
		<li><a href="c_work.html">Контрольная работа</a></li>
		
		<li role="separator" class="divider"></li>
		
		<li><a href="lit.html">Литература</a></li>


 
    </ul>
 
</li>
 </ul>
  </div><!-- /.navbar-collapse -->
 </div><!-- /.container-fluid -->
</nav>


<div id="intro" class="section content-section ">
    <div class="container">
		<div class="row">
			<div class="col-lg-12">	
				
			<div class="page-header">
				<h3>5. Представление вещественных чисел</h3>
		
				<a href="lii_5.html#5_1" class="punkt">5.1 Общие сведения</a>
				<br>
				<a href="lii_5.html#5_2" class="punkt">5.2 Схема записи вещественного нормализованного числа в ячейку памяти компьютера на примере типа Real (Turbo Pascal)</a>
				<br>
				<a href="lii_5.html#5_3" class="punkt">5.3 Сопроцессорные вещественные типы языка TP</a>
				<br>
				<a href="lii_5.html#5_4" class="punkt">5.4 Арифметические операции</a>
				<br>
				<a href="lii_5.html#v" class="punkt">Вопросы и задачи для самопроверки</a>
				<br>
			</div>
			
			
			
			<a name="5_1" class="anchor"></a>
			<h3>5.1 Общие сведения</h3>
			  
			  <P><I>&#9;</i>Как и для представления целых чисел, для представления
				вещественных чисел в компьютере используется чаще всего двоичная система
				счисления (реже 2-16–ичная). Независимо от используемых систем счисления,
				существуют два типа представления чисел в компьютере: с <B><I>фиксированной
				запятой</i></B> и с <B><I>плавающей запятой</i></B>.</P>
			  <P>&#9;Если используется представление с <B><I>фиксированной
				запятой</i></B>, все разряды ячейки памяти служат для изображения разрядов
				числа (кроме знакового разряда, если он существует). При этом одному и
				тому же разряду числа соответствует всегда один и тот же разряд ячейки.
				Т.е. место запятой фиксируется около определённого разряда. Именно в таком
				виде представлены целые числа в компьютере. Место запятой при этом – после
				младшего разряда, вне разрядной сетки. Такая система записи числа упрощает
				выполнение арифметических операций, но сильно ограничивает диапазон представляемых
				чисел. </P>
			  <P>Делались попытки представить в подобном виде и вещественные
				числа. Чаще всего это были числа из диапазона [–1,1]. Число в компьютере
				предлагалось представлять, к примеру, следующим образом: </P>
			  <P>
			  
				<TABLE BORDER CELLSPACING=1 CELLPADDING=1 WIDTH=265>
				  <TR> 
					<TD WIDTH="12%" VALIGN="TOP" HEIGHT=25> <IMG SRC="img/Image1595.gif" WIDTH=17 HEIGHT=18></TD>
					<TD WIDTH="13%" VALIGN="TOP" HEIGHT=25> <IMG SRC="img/Image1596.gif" WIDTH=20 HEIGHT=28 ></TD>
					<TD WIDTH="14%" VALIGN="TOP" HEIGHT=25> <IMG SRC="img/Image1597.gif" WIDTH=22 HEIGHT=28></TD>
					<TD WIDTH="47%" VALIGN="TOP" HEIGHT=25> ……………</TD>
					<TD WIDTH="14%" VALIGN="TOP" HEIGHT=25> <IMG SRC="img/Image1598.gif" WIDTH=24 HEIGHT=29></TD>
				  </TR>
				</TABLE>
			  
			  <p></P>
			  <P>Этот случай соответствует соглашению, что запятая стоит перед самым старшим
				разрядом, а число, соответствующее такой записи, равно</P>
			  <IMG SRC="img/Image1599.gif">
			  <P>&#9;Наибольшее по абсолютной величине число, которое
				может быть представлено в компьютере таким образом, равно 1–р<SUP>–n</SUP>,
				а наименьшее равно – р<SUP>–n</SUP>. Поскольку реально числа бывают и
				больше, и меньше этого диапазона, приходилось вводить “масштабные множители”,
				что существенно усложняло решение задачи.</P>
			  <P>&#9;<B>Поэтому в современных ЭВМ принят другой способ
				представления вещественных чисел – с плавающей запятой.</B> Этот способ
				опирается на нормализованную (экспоненциальную) запись числа.</P>
				 
			  <P><B>Замечание</b>. Термин “экспонента” имеет два близких, 
				но всё же различных значения. Первое – это функция <IMG SRC="img/Image1600.gif" WIDTH=22 HEIGHT=28 align="absbottom">. 
				В математических книгах часто встречается запись exp(x) (как и в большинстве 
				языков программирования). Второе значение экспоненты – показатель степени 
				вообще. Например, для числа <IMG SRC="img/Image1601.gif" WIDTH=30 HEIGHT=28 align="absbottom">, 
				3 будет экспонентой. Именно в этом смысле используется буква E при записи 
				чисел в калькуляторах и языке Паскаль:<IMG SRC="img/Image1602.gif" WIDTH=176 HEIGHT=30 >.</P>
			  <P><I><B>Нормализованная форма</b></i> записи неравного
				нулю вещественного числа – это представление числа в виде <IMG SRC="img/Image1603.gif" WIDTH=100 HEIGHT=32 >,
				где q – целое число (положительное, отрицательное или ноль), <I>m</I>
				– правильная p-ичная дробь, у которой <U>первая цифра после запятой не
				равна нулю</U>: 
				<br>
				<IMG SRC="img/Image1604.gif" WIDTH=90 HEIGHT=57 >,<br> p – основание
				системы счисления. 
				<br>
				При этом <I>m</I> называют <B><I>мантиссой</i></B>,
				а q – <B><I>порядком числа</i></B>.</P>
			  <P>В нормализованном виде мантисса записывается в p-ичном 
				виде, а порядок – в десятичном.</P>
			  <P>&nbsp;</P>
			  <P><B>Пример 1</b>.&#9;Записать в нормализованном виде.</P>
			  <P>0,0017<SUB>10</SUB>=0,17x 10<SUP>–2</SUP>, здесь m=0,17; 
				q= –2; p=10;</P>
			  <P>100,01<SUB>2</SUB>=0,10001x 2<SUP>3</SUP>, здесь m=0,10001; 
				q= 3; p=2;</P>
			  <P></P>
			  <P>Следует отметить, что число ноль не может быть записано
				в нормализованной форме так, как она определена, поэтому его запись оговаривается
				отдельно: <IMG SRC="img/Image1605.gif" WIDTH=101 HEIGHT=32 >(и мантисса, и
				порядок равны нулю).</P>
			  <P>Нормализованной такая форма записи названа потому, что
				в ней все числа записываются одинаково (по единой норме), в том смысле,
				что запятая ставится всегда в одном и том же месте – перед самой старшей
				(левой) значащей цифрой.</P>
			  <P>Итак, теперь мы будем рассматривать только нормализованные
				числа, представленные в виде: <IMG SRC="img/Image1606.gif" WIDTH=181 HEIGHT=32 >–
				т.к. при представлении в компьютере используется двоичная система счисления.      </P>
			  <P>Для представления вещественного числа в компьютере выделяется
				ячейка памяти, часть разрядов которой отводится для записи мантиссы, часть
				– для записи порядка, и один разряд – для записи знака числа.</P>
			  <P>Как правило, в любом языке программирования используется 
				несколько вещественных типов, которые отличаются размером ячейки памяти, 
				различным количеством разрядов, отведённых под мантиссу и порядок, и местом 
				их расположения.</P>
			 
			  <P>Таблица 6: Вещественные типы языков TP и С.</P>
			  
			  <TABLE BORDER CELLSPACING=1 CELLPADDING=1 WIDTH=500>
				<TR> 
				  <TD WIDTH="13%" VALIGN="MIDDLE"> Размер в байтах</TD>
				  <TD WIDTH="27%" VALIGN="MIDDLE"> Диапазон значений</TD>
				  <TD WIDTH="28%" VALIGN="MIDDLE"> Точность</TD>
				  <TD WIDTH="14%" VALIGN="MIDDLE"> Название<br>
					в ТР</TD>
				  <TD WIDTH="18%" VALIGN="MIDDLE"> Название в С</TD>
				</TR>
				<TR> 
				  <TD WIDTH="13%" VALIGN="MIDDLE"> 6</TD>
				  <TD WIDTH="27%" VALIGN="MIDDLE"> 10<SUP>-39</SUP>…10<SUP>38</SUP></TD>
				  <TD WIDTH="28%" VALIGN="MIDDLE"> 11-12 знач. цифр</TD>
				  <TD WIDTH="14%" VALIGN="MIDDLE"> Real</TD>
				  <TD WIDTH="18%" VALIGN="MIDDLE">&nbsp;</TD>
				</TR>
				<TR> 
				  <TD WIDTH="13%" VALIGN="MIDDLE"> 4</TD>
				  <TD WIDTH="27%" VALIGN="MIDDLE"> 10<SUP>-45</SUP>…10<SUP>38</SUP></TD>
				  <TD WIDTH="28%" VALIGN="MIDDLE"> 7-8 знач. цифр</TD>
				  <TD WIDTH="14%" VALIGN="MIDDLE"> single</TD>
				  <TD WIDTH="18%" VALIGN="MIDDLE"> float</TD>
				</TR>
				<TR> 
				  <TD WIDTH="13%" VALIGN="MIDDLE"> 8</TD>
				  <TD WIDTH="27%" VALIGN="MIDDLE"> 10<SUP>-324</SUP>…10<SUP>308</SUP></TD>
				  <TD WIDTH="28%" VALIGN="MIDDLE"> 15-16 знач. цифр</TD>
				  <TD WIDTH="14%" VALIGN="MIDDLE"> double</TD>
				  <TD WIDTH="18%" VALIGN="MIDDLE"> double</TD>
				</TR>
				<TR> 
				  <TD WIDTH="13%" VALIGN="MIDDLE"> 10</TD>
				  <TD WIDTH="27%" VALIGN="MIDDLE"> 10<SUP>-4951</SUP>…10<SUP>4932</SUP></TD>
				  <TD WIDTH="28%" VALIGN="MIDDLE"> 19-20 знач. цифр</TD>
				  <TD WIDTH="14%" VALIGN="MIDDLE"> extended</TD>
				  <TD WIDTH="18%" VALIGN="MIDDLE"> long int</TD>
				</TR>
			  </TABLE>
			  
			  <h3><a name="5_2" class="anchor"></a>5.2 Схема записи вещественного нормализованного 
				числа в ячейку памяти компьютера на примере типа Real (Turbo Pascal)</h3>
			  
			  <P>Тип real не случайно приведён в таблице 6 первым, хотя
				его размер не является минимальным. Дело в том, что на современных компьютерах
				для работы с вещественными числами используются сопроцессоры (раньше их
				ставили дополнительно, а сейчас они встроены в процессор). А процессор
				работает только с целыми числами. </P>
			  <P>Так вот, первые компиляторы для языка TP разрабатывались
				тогда, когда персональные компьютеры сопроцессоров не имели, а система
				команд процессора содержала операции лишь над целыми числами (и по сей
				день тип <I>real</I> не использует сопроцессоры). Реализацию арифметических
				операций над вещественными числами разработчики вынуждены были проводить
				самостоятельно. Поэтому схема записи числа такого типа отличается от других
				вещественных типов, которые являются сопроцессорными.</P>
			  <P>Как следует из таблицы, под каждую переменную типа <I>real</I>
				отводится 6 байт памяти. Распределены они следующим образом: старший разряд
				– под знак числа, младшие 8 разрядов – под запись порядка, остальные –
				под запись мантиссы. Схема записи такого числа изображена на рисунке (k<SUB>m</SUB>,
				k<SUB>q </sub>–количество разрядов, отведённых под мантиссу и под порядок):</P>
			  
			  
			  <TABLE BORDER CELLSPACING=1 CELLPADDING=1 WIDTH=500>
				<TR> 
				  <TD WIDTH="14%" VALIGN="TOP"> <div><b>47</b></div></TD>
				  <TD WIDTH="8%" VALIGN="TOP"> <div><b>46</b></div></TD>
				  <TD WIDTH="47%" VALIGN="TOP"><div></div></TD>
				  <TD WIDTH="8%" VALIGN="TOP"> <div><b>8</b></div></TD>
				  <TD WIDTH="8%" VALIGN="TOP"> <div><b>7</b></div></TD>
				  <TD WIDTH="11%" VALIGN="TOP"><div></div></TD>
				  <TD WIDTH="6%" VALIGN="TOP"> <div><b>0</b></div></TD>
				</TR>
				<TR> 
				  <TD WIDTH="14%" VALIGN="TOP"> <div>знак <BR>
					мантиссы</div></TD>
				  <TD WIDTH="62%" VALIGN="TOP" COLSPAN=3> <div><I><B>m</b></i> <BR> 
					  <I>k<SUB>m</sub></I> 
					= 39 разрядов</div></TD>
				  <TD WIDTH="24%" VALIGN="TOP" COLSPAN=3> <div><I><B>q + t</b></i><BR> 
					  <I>k<SUB>q</sub></I> 
					= 8 разрядов</div></TD>
				</TR>
			  </TABLE>
			  
			  <P>&#9;Т.к. в двоичной системе счисления в нормализованной
				форме после запятой всегда стоит 1, число <U>всегда в виде</U>: <IMG SRC="img/Image1607.gif" WIDTH=118 HEIGHT=30>,
				то эту “старшую” единицу в типе real не записывают в мантиссу. Т.е m здесь
				– <U>мантисса без старшей единицы</U>. При арифметических операциях эта
				единица восстанавливается.</P>
			  <P>Знак числа записывается так: 0 – положительное число;
				1 – отрицательное. Знак мантиссы есть знак всего числа.</P>
			  <P>&#9;Однако и порядок числа может быть как отрицательным,
				так и положительным целым числом. При представлении целых чисел для записи
				отрицательных величин использовался дополнительный код. <B>Но в записи
				вещественных чисел он не используется. </b></P>
			  
			  <P> <B>Порядок числа записывается в специальном виде q+t,
			  где q – собственно порядок, а t –</b> <B>сдвиг (смещение) порядка</B>.      </P>
			  <P>Сдвиг вычисляется по формуле:</P>
			  <P> <IMG SRC="img/Image1608.gif" WIDTH=80 HEIGHT=30></P>
			  <P>Если под запись порядка, как в данном случае, выделено
				8 разрядов (k<SUB>q</SUB>=8), то сдвиг будет <IMG SRC="img/Image1609.gif" WIDTH=161 HEIGHT=28 >.</P>
			  <P>&#9;Сдвиг порядка используется для того, что бы порядок
				всегда представлялся в виде положительного беззнакового числа и все восемь
				нулей в записи порядка со сдвигом соответствовали минимальному возможному
				порядку (а не q = 0).</P>
			  <P>&#9;Действительно, если <I>t</I> = 128, и в разрядах,
				отведённых под порядок со сдвигом, записано 8 нулей: 0000 0000. Чему тогда
				равен порядок?</P>
			  <P> <I>q</I>+<I>t </I>= 0000 0000<SUB>2</SUB> = 0. <IMG SRC="img/Image1610.gif" WIDTH=25 HEIGHT=18>
				<I>q</I> = –<I>t</I> = –128. Это будет минимальный возможный порядок для
				данной ячейки.</P>
			  <P>&#9;Если в разрядах, отведённых под порядок со сдвигом,
				все единицы: </P>
			  <P>1111 1111<SUB>2</SUB> =255 <IMG SRC="img/Image1611.gif" WIDTH=25 HEIGHT=18>
				255 = <I>q</I>+<I>t </I><IMG SRC="img/Image1612.gif" WIDTH=25 HEIGHT=18> <I>q</I>
				= 255 – 128 = 127. Это будет максимальный возможный порядок для данной
				ячейки.</P>
			  <P>&#9;Наоборот, если порядок <I>q</I> = 0, что будет записано
				в соответствующих разрядах?</P>
			  <P><I>q</i>+<I>t </I>= 0 + 128 <IMG SRC="img/Image1613.gif" WIDTH=25 HEIGHT=18>
				Там будет записано 1000 0000.</P>
			  <P> В общем, можно сделать вывод: если реальный порядок
				отрицательный, то в старшем из этих 8-ми разрядов будет 0, а если не отрицательный
				(<IMG SRC="img/Image1614.gif" WIDTH=30 HEIGHT=21>), то там стоит 1( наоборот
				со знаком мантиссы).</P>
			  <P>&#9;А смысл введения сдвига порядка был следующий: при
				таком представлении упрощалась операция сравнения числа с нулём, которая
				аппаратно выполняется довольно часто.</P>
			  <P>&#9;Таким образом, любое число типа real имеет следующий 
				нормализованный вид:</P>
			  <P><IMG SRC="img/Image1615.gif" WIDTH=118 HEIGHT=30 >, 
				где <IMG SRC="img/Image1616.gif" WIDTH=98 HEIGHT=28 >, <IMG SRC="img/Image1617.gif" WIDTH=133 HEIGHT=25>.</P>
			  <P>&nbsp;</P>
			  <P><B>Пример 2</b>. В ячейке, отведённой под число типа
				real, все разряды заняты нулями. Что это за число?</P>
			  <P></P>
			  <TABLE BORDER CELLSPACING=1 CELLPADDING=1 WIDTH=444>
				<TR> 
				  <TD WIDTH="5%" VALIGN="TOP"> 0</TD>
				  <TD WIDTH="74%" VALIGN="TOP"> 000 . . . 0</TD>
				  <TD WIDTH="21%" VALIGN="TOP"> 0 0000000</TD>
				</TR>
			  </TABLE>
			  <p>&nbsp;</p><P></P>
			  <P>Т.к. в знаковом разряде стоит 0, это число положительное.
				Его мантисса равна 0,1 (т.к. при записи в ячейку памяти старшую единицу
				не писали, но теперь мы её восстанавливаем). Найдём порядок: <I>q</I>
				+ <I>t</I> = 0 <IMG SRC="img/Image1618.gif" WIDTH=25 HEIGHT=18> <I>q</I> =
				–<I>t</I> = –128. Т.е. это число:</P>
			  <P> <IMG SRC="img/Image1619.gif" WIDTH=602 HEIGHT=32>(т.е. получили
				очень маленькое, но всё же не равное нулю, как можно было подумать, число).
				Получили машинный ноль.</P>
			  <P></P>
			  <P>Минимальное представимое в данном типе число называется
				<B><I>машинным нулём</i></B>.</P>
			  <P></P>
			  <P><B>Пример 3</b>. Что за число записано в ячейке памяти,
				если все разряды, кроме знакового, заняты нулями?</P>
			  <TABLE BORDER CELLSPACING=1 CELLPADDING=1 WIDTH=444>
				<TR> 
				  <TD WIDTH="5%" VALIGN="TOP"> 1</TD>
				  <TD WIDTH="74%" VALIGN="TOP"> 000 . . . 0</TD>
				  <TD WIDTH="21%" VALIGN="TOP"> 0 0000000</TD>
				</TR>
			  </TABLE>
			  <p>&nbsp;</p><P></P>
			  <P>Т.к. в знаковом разряде стоит 1, это число отрицательное;
				все остальные рассуждения аналогичны примеру 2. Т.е. записанное число
				равно <IMG SRC="img/Image1620.gif" WIDTH=94 HEIGHT=30 align="absbottom">– это “минус ноль”.      </P>
			  <P><B>Т.е. машинных нуля два : один +0, другой –0</b>.</P>
			  <P>&#9;<B><FONT COLOR="#ff0000">Таким образом представить
				“просто ноль” в типе real нельзя, т.к. в мантиссе всегда неявно присутствует
				единица</font></B>.</P>
			  <P>&#9;Т.к. для записи мантиссы отведено определённое количество 
				разрядов, то возможны случаи, когда все цифры мантиссы в эти разряды не 
				помещаются. Тогда число округляется по следующему правилу: если надо округлить 
				до <I>k</I>-го разряда (включительно), то смотрят <I>k</I>+1 разряд. Если 
				там ноль – просто отбрасывают оставшуюся часть, если там 1 – эту единицу 
				прибавляют к <I>k</I>-му разряду.</P>
			  <P>&nbsp;</P>
			  <P><B>Пример 4. </b>Примеры округления до 5-го разряда двоичных
				чисел:</P>
			  <P> 1) 0,100111111 т.к. в 6-м разряде стоит 1, прибавляем
				к 5-му разряду 1:</P>
			  <P> 0,10011+0,00001 =0,10100 – после округления.</P>
			  <P> 2) 0,100110111 т.к. в 6-м разряде стоит 0, отбрасываем
				все значащие цифры после 5-го разряда: 0,10011– после округления.</P>
			  <P>&nbsp;</P>
			  <P><B>Пример 5.</b>Записать в ячейку памяти типа REAL число 12,25<sub>10</sub>.
		Переведём число в двоичную систему и нормализуем:</P>
		<p>12,25<sub>10</sub>=1100,01<sub>2</sub>=0,110001&times;2<sup>4</sup>;</p>
		<p>Вычислим порядок со сдвигом: q=4 (порядок), <img src="img/image299.gif" > (сдвиг).
		<p>q+t=4+128=132<sub>10</sub>=10000100<sub>2</sub>.</p>
		<p>Т.к. число положительное, в знаковый разряд пишем ноль, затем идёт мантисса без старшей единицы и порядок со сдвигом:</p>
		<p>&nbsp;</p>
		<table border=1 width=40%>
		<tr><td width="5%">0</td><td width="25%">100010000 . . .</td><td width="10%">10000100</td></tr>
		</table>

		<p>&nbsp;</p>
			  <P>&#9;Вычислим границы диапазона типа Real. Запишем в ячейку
				памяти максимально возможное по абсолютной величине число (в знаковом
				разряде 0, в остальных 1). Чему равно такое число?</P>
			  <P><IMG SRC="img/Image1621.gif"></P>
			  <P>А минимальное по модулю число мы уже нашли – это машинный 
				ноль, который <IMG SRC="img/Image1622.gif" WIDTH=144 HEIGHT=28>.</P>
			  <P>Таким образом, диапазон чисел, представимых в типе real:</P>
			  <P>(<IMG SRC="img/Image1623.gif" WIDTH=113 HEIGHT=32 >).</P>
			  <P>&#9;Этот диапазон говорит лишь о величине представимых
				чисел, но не о точности представления. Это вовсе не значит, что мы можем
				в типе real представить число, состоящее из 38 десятичных цифр. Во-первых,
				десятичное число, даже имеющее всего одну значащую цифру после запятой,
				вообще говоря, невозможно записать точно в любом из вещественных типов.
				Подробнее этот вопрос мы обсудим в пункте 5.4. Во-вторых, на точность
				представления чисел влияет размер мантиссы. В данном случае мантисса может
				состоять из 40-значащих двоичных цифр (39 записываются явно, а одна подразумевается).
				Это позволяет записать число, состоящее из 40 единиц, которое равно <IMG SRC="img/Image1624.gif" WIDTH=298 HEIGHT=32 >.
				Это и даёт 10-12 значащих цифр, указанных в таблице 6.</P>
			  
			  <h3><a name="5_3" class="anchor"></a>5.3 Сопроцессорные вещественные типы 
				языка TP.</h3>
			  
			  <P>Как уже было сказано, в современных компьютерах с вещественными числами работает не процессор, а сопроцессор. Чтобы обеспечить в своих системах поддержку сопроцессорных типов, Borland вводит в Turbo Pascal типы Single (4 байта), Double  (8 байт) и Extended (10 байт). Extended – это родной для сопроцессора тип, а типы Single и Double получаются из него очень простым усечением. При загрузке числа типа Single или Double во внутренний регистр сопроцессора последний конвертирует их в Extended. Напротив, при выгрузке чисел этих типов из регистра в память сопроцессор усекает их до нужного размера. Внутренние же операции всегда выполняются с данными типа Extended.</P>
			  <P>При представлении этих чисел в компьютере мантисса и порядок меняются местами, оставляя неизменным расположение знакового разряда:</P>
			  
			 
				<TABLE BORDER CELLSPACING=1 CELLPADDING=1 WIDTH=427>
				  <TR> 
					<TD WIDTH="12%" VALIGN="TOP"> знак</TD>
					<TD WIDTH="53%" VALIGN="TOP"> <I> q+t –</i>порядок со сдвигом</TD>
					<TD WIDTH="35%" VALIGN="TOP"> мантисса(<I>m</I>)</TD>
				  </TR>
				</TABLE>
			  
			 
			  <P>В сопроцессорных типах порядок так же представляется
				с использованием сдвига. Но в этих типах данных (в extended всегда, а
				в остальных только в случае, когда <I>q</I> + <I>t</I> =0) число предварительно преобразовывается к виду: </P>
			  <P><IMG SRC="img/Image1625.gif" WIDTH=113 HEIGHT=30 >, где <IMG SRC="img/Image1626.gif" >,        </P>
			  <P>и сдвиг вычисляется по формуле <IMG SRC="img/Image1627.gif" WIDTH=112 HEIGHT=30 align="baseline">.
				Найдём минимально и максимально возможный порядок:</P>
			  <P><I>q</i> + <I>t</I> = 0 (<I>min</I>) <IMG SRC="img/Image1628.gif" WIDTH=25 HEIGHT=18>
				<I>q</I> = –<I>t</I> (<IMG SRC="img/Image1629.gif" WIDTH=100 HEIGHT=29>)</P>
			  <P><IMG SRC="img/Image1630.gif" WIDTH=461 HEIGHT=60></P>
			  <P><IMG SRC="img/Image1631.gif" WIDTH=370 HEIGHT=34></P>
			  <P>Т.е. <IMG SRC="img/Image1632.gif" WIDTH=116 HEIGHT=25></P>
			  <P>Т.о. в этих типах минимальная ненулевая мантисса состоит
				из <I>n</I>–1 нуля после запятой и одной самой правой единицы:</P>
			  <P></P>
			  <TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=430>
				<TR>
				  <TD WIDTH="7%" VALIGN="TOP"> <P>0</TD>
				  <TD WIDTH="48%" VALIGN="TOP"> <P>0 .. ..0 </TD>
				  <TD WIDTH="45%" VALIGN="TOP"> <P>00… .. 01</TD>
				</TR>
			  </TABLE>
			  <P></P>
			  <P><IMG SRC="img/Image1633.gif" WIDTH=268 HEIGHT=56></P>
			  <P>Отсюда и возникает несимметричность в допустимом диапазоне
				значений (на него теперь влияем не только порядок, но и мантисса).&#9;</P>
			  <P><B>Пример 6 </b>. Найдём минимальное представимое число
				для типа single (4 байта). В этом типе <IMG SRC="img/Image1634.gif" WIDTH=141 HEIGHT=32 >.</P>
			  <P><IMG SRC="img/Image1635.gif" WIDTH=316 HEIGHT=30>.</P>
			  <P>Соответственно, минимальное представимое число будет:</P>
			  <P><IMG SRC="img/Image1636.gif" WIDTH=650 HEIGHT=32></P>
			  
			  <h3><a name="5_4" class="anchor"></a>5.4 Арифметические операции.</h3>
			  
			  <P>&#9;При выполнении арифметических операций над числами,
				представленными в формате с плавающей запятой, надо отдельно выполнять
				операции для мантисс и порядков. <U>Но сначала числа нормализуются!</u></P>
			  <P></P>
			  <P>&nbsp;</P>
			  <div><b><i>Алгоритм компьютерного сложения (вычитания) вещественных 
				чисел</i></b> </div>
			  <OL>
				<P>
				<LI>Порядки чисел <I>а</I> и <I>b</I> выравниваются по большему из них
				  (пусть, для определённости, это будет число <I>a</I>). Для этого мантисса
				  числа <I>b</I> сдвигается <U>вправо</U> на соответствующее количество
				  разрядов (часть значащих цифр при этом может оказаться утерянной).</LI>
				<p></P>
				<P>
				<LI>Выполняется операция сложения (вычитания) над мантиссами с округлением
				  по значению (k+1) –ой значащей цифры результата;</LI>
				<p></P>
				<P>
				<LI>Мантисса результата нормализуется, поэтому получившийся порядок может
				  измениться как в меньшую, так и в большую сторону.</LI>
				<p></P>
			  </OL>
			  <P><B>Пример 7</b>. Пусть длина мантиссы 8 разрядов. Вычислим
				разность чисел <IMG SRC="img/Image1637.gif" WIDTH=65 HEIGHT=28> и <IMG SRC="img/Image1638.gif" WIDTH=90 HEIGHT=28>.
				Сначала оба числа нормализуем: </P>
			  <P><IMG SRC="img/Image1639.gif" WIDTH=148 HEIGHT=32> <IMG SRC="img/Image1640.gif" WIDTH=105 HEIGHT=30>.      </P>
			  <P><IMG SRC="img/Image1641.gif" WIDTH=468 HEIGHT=32></P>
			  <DIR>
			  <P><IMG SRC="img/Image1642.gif" WIDTH=565 HEIGHT=32></P>
			  <P>Выполним вычитание мантисс:</P>
			  </DIR>
			  <P> _0,10000 </P>
			  <P> <U>&nbsp;&nbsp;0,00011</u></P>
			  <P> &nbsp;&nbsp;0,01101</P>
			  <P></P>
			  <P>Результат <I>a-b</I>= <IMG SRC="img/Image1643.gif" WIDTH=224 HEIGHT=58 align="top"></P>
			  <P></P>
			  <P>Рассмотрим теперь ошибки, которые могут возникнуть при
				операциях сложения и вычитания.</P>
			  <OL>
				<OL>
				  <P> 
				  <LI><I><B>Потеря значащих цифр мантиссы у меньшего из чисел при выравнивании
						 порядков</b></i>.</LI>
				  <p><B>Пример 8 </b>. Пусть длина мантиссы 8 разрядов. 
				  Вычислить сумму чисел:</p>
				  <p><IMG SRC="img/Image1644.gif" WIDTH=110 HEIGHT=32 >и <IMG SRC="img/Image1645.gif" WIDTH=97 HEIGHT=30 >.</p>
				  <p><IMG SRC="img/Image1646.gif" WIDTH=422 HEIGHT=58></p>
				  <p><IMG SRC="img/Image1647.gif" WIDTH=325 HEIGHT=32></p>
				  <p><img src="img/exii5_6_1.gif" width="169" height="109">&#9;</p>
				  <p>Поскольку
					длина мантиссы 8 разрядов, то последние цифры будут отброшены при
					округлении, в результате получим <I>a </I>+ <I>b </I>= <I>a</I> (что
					в обычной математике не бывает, если <IMG SRC="img/Image1649.gif" WIDTH=46 HEIGHT=22 >).&#9;          </p>
				  <P> 
				  <LI><b><i>Потеря значащих цифр мантиссы результата при вычитании близких
						 по модулю чисел.</i></b></LI>
				  <p></P>
				  <P><B>Пример 9.</b> Пусть длина мантиссы 8 разрядов.
					 Вычислить разность чисел <IMG SRC="img/Image1650.gif" WIDTH=118 HEIGHT=28 >и 
					<IMG SRC="img/Image1651.gif" WIDTH=120 HEIGHT=28 >.</P>
				  <P>а) Сначала произведём вычисления вне зависимости
					 от разрядности мантиссы: </P>
				  <p><img src="img/exii5_8.gif" width="222" height="79"><img src="img/Image1652.gif" width=512 height=26></p>
				  <p>&nbsp;</p>
				  <P>= <IMG SRC="img/Image1654.gif" WIDTH=401 HEIGHT=53 >=0,003125<SUB>10</SUB>.          </P>
				  <P>Это точный “теоретический” результат.</P>
				  <P>б) теперь вычислим <I>a</I>–<I>b </I>c учётом разрядности
					 мантиссы:</P>
				  <P>число <I>a</I> будет записано как: 0,110011001100(1100).
					 После округления до 8-ми разрядов, а=0,1100110<B>1,</B> и</P>
				  <p><img src="img/exii5_8_2.gif" width="471" height="86">          </p>
				  <p>Сравним с ранее полученным результатом. Уже вторая
					 значащая цифра оказалась неверной.</p>
				  <P></P>
				  <P> 
				  <LI><I><B>Выход за границу допустимого диапазона значений типа при
						нормализации  результата</b></i>.</LI>
				  <p></P>
				</OL>
			  </OL>
			  <P>В данном случае получаемый порядок оказывается либо больше 
				максимально возможного значения, либо меньше минимального:</P>
			  <P>&nbsp;</P>
			  <P><B>Пример 10 </b>. <IMG SRC="img/Image1657.gif" >      </P>
			  <P>Если числа <I>a</I> и <I>b</I> являются переменными типа 
				real, то результат окажется непредставимым в данном типе. Такую ситуацию 
				разные компиляторы обрабатывают по-разному, чаще всего выдаётся сообщение 
				об ошибке: “арифметическое переполнение”.</P>
			  <P>&nbsp;</P>
			  <div><b><i>Алгоритм компьютерного умножения (деления) вещественных 
				чисел.</i></b> </div>
			  <OL>
				<P>
				<LI>Мантиссы перемножаются (или делятся), результат округляется <U>до 
				  <I>k</I>&nbsp; значащих цифр</U> (предварительно выравнивать порядки не требуется).</LI>
				<p></P>
				<P>
				<LI>Порядки при умножении складываются, а при делении вычитаются.</LI>
				<p></P>
				<P>
				<LI>При необходимости мантисса результата нормализуется.</LI>
				<p></P>
			  </OL>
			  <P></P>
			  <P><B>Пример 11</b>. Найти <I>axb, a &#58; b</I>, если <I>a=</I>0, 
				001101<SUB>2</SUB>,<I> b=</I>100,1<SUB>2</SUB>, длина мантиссы 8 разрядов.</P>
			  <P>Нормализуем числа:</P>
			  <P><I>a=</i>0,1101x 2<SUP>–2</SUP>,<I> b=</I>0,1001x 2<SUP>3 
				</SUP>.</P>
			  <P>1) <I>ax b</I>=(0,1101x 2<SUP>–2</SUP>)&#180; (0,1001x 
				2<SUP>3</SUP>)=(0,1101 x 0,1001) x 2<SUP>–2+3</SUP>=0,1110101x2 (округлять 
				и нормализовать нет необходимости).</P>
			  <P>2) <I>a &#58; b</I>=(0,1101x 2<SUP>–2</SUP>)&#58; (0,1001x 
				2<SUP>3</SUP>) =(0,1101 &#58; 0,1001) x 2<SUP>–2–3</SUP>=</P>
			  <P>=1,01110000111….x2<SUP>–5</SUP>= нормализуем =0,101110000111….x 
				2<SUP>–4 </SUP>= округляем по 8-ой разряд = 0, 10111000x 2<SUP>–4</SUP>.</P>
			  <P></P>
			  <P>При умножении и делении, так же как и при сложении, возможно
				возникновение арифметического переполнения, или получение машинного нуля
				вместо достаточно малого, но не равного нулю числа.</P>
			  <P></P>
			  <P><B>Замечание.</b> При выполнении промежуточных вычислений
				или при сдвиге порядка у одного из чисел мантисса записывается в отведённыё
				разряды полностью (включая старшую единицу после запятой). Старшая единица
				мантиссы не хранится только у результата после нормализации. </P>
			  <P></P>
			  <P>&#9;Выполнение арифметических операций с вещественными
				числами требует проведения нормализации, что приводит к изменению порядков.
				Этим и объясняется термин “плавающая запятая”, т.е. запятая “плавает”
				с места на место.</P>
			  <P></P>
			  <P><B>Пример 12</b>. Рассмотрим, как будет выглядеть запись
				мантиссы (<I>m</I>) числа а=<IMG SRC="img/Image1658.gif" WIDTH=45 HEIGHT=29 >при
				различных значениях <IMG SRC="img/Image1659.gif" WIDTH=32 HEIGHT=29 >– количества
				разрядов, отведённых под мантиссу. Сначала переведём число в двоичный
				вид с указанием периода и нормализуем:</P>
			  <P>а=<IMG SRC="img/Image1660.gif" WIDTH=434 HEIGHT=33 >– нормализовали.</P>
			  <P>1) Пусть <IMG SRC="img/Image1661.gif" WIDTH=70 HEIGHT=29 >
				“Запишем” мантиссу в это количество разрядов, округлив до соответствующего
				знака:</P>
			  <P> <IMG SRC="img/Image1662.gif"> .</P>
			  <P>Теперь “восстановим” это число:</P>
			  <P><IMG SRC="img/Image1663.gif" WIDTH=589 HEIGHT=53></P>
			  <P>2) Пусть <IMG SRC="img/Image1664.gif" >.
				Вновь запишем мантиссу:</P>
			  <P><IMG SRC="img/Image1665.gif" WIDTH=332 HEIGHT=28 >. (округлили)</P>
			  <P>Теперь “восстановим”:</P>
			  <P><IMG SRC="img/Image1666.gif" WIDTH=665 HEIGHT=53></P>
			  <P>Сравним полученные результаты. Вспомним, что записывали
				в память число 0,2. В первом случае получили приближение числа с избытком,
				во втором – с недостатком. Но точно исходное число мы записать не сможем.
				Это объясняется тем, что конечные десятичные дроби часто оказываются бесконечными
				периодическими двоичными дробями. Значит, в нормализованном виде число
				будет иметь бесконечную мантиссу, которую придётся округлить при записи
				в конечное число разрядов.</P>
			
			  <P>&nbsp;</P>
			  
			  <P><B>Пример 13</b>. Вопрос, что напечатает программа после запуска?</P>
			  <p><em>var  R1:single: R2:double;</em></p>
			  <p><em>begin </em></p>
			  <p><em>    R1:=0.2;</em></p>
			  <p><em>    R2:=0.2:</em></p>
			  <p><em>    if R1=R2 then writeln(‘</em><em>Равно</em><em>’)</em></p>
			  <p><em>                    else writeln(‘</em><em>Не</em><em>равно</em><em>’);</em></p>
			  <p><em>end.</em></p>
			  <P>&nbsp;</P>
			  <p>Т.к. число 0.2 не представимо в виде конечной  десятичной дроби (как мы выяснили, дробь периодическая), в зависимости от типа переменной  мантисса будет округлена до разного количества десятичных знаков, следовательно,  они не будут равны.</p>
			  <P>&nbsp;</P>
			  <P><B>Пример 14</b>. Задача – написать на языке <em>Pascal</em>  программу,  вычисляющую значения функции f(x)=x<sup>2</sup> на  отрезке [0,1] с шагом 0,2. Типичная для начинающих программистов программа  выглядит следующим образом:</P>
			  <p><em>var a:real;</em></p>
			  <p><em>begin         a:=0.0;</em></p>
			  <p><em>                   while a&lt;&gt;1  do</em></p>
			  <p><em>                   begin</em></p>
			  <p><em>                            writeln(‘a=’,a,’  f(a)=’, sqr(a));</em></p>
			  <p><em>                            a</em><em>:=</em><em>a</em><em>+0.2;</em></p>
			  <p><em>end;</em></p>
			  <p><em>end.</em></p>
			  <p>Т.к. число 0.2 точно в компьютере не представимо, следовательно, если к 0.0 пять раз прибавить 0.2, ровно 1 не получится (будет число либо чуть-чуть меньше 1, либо чуть-чуть больше). И программа «зациклится».</p>
			  <p>&nbsp;</p>
			  <p><u>Итог.</u></p>
			  <ol>
			  <li>Уже на этапе записи чисел в компьютер возникают ошибки округления, которые нарастают при выполнении арифметических операций.</li>
			  <li>В результате вычитания могут возникнуть ненадёжные значащие цифры.</li>
			  <li>Добавление или вычитание очень малого числа может никак не сказаться на результате.</li>
			  <li>Получение очень больших чисел может вызвать переполнение порядка, а очень малого – появление нуля (что может вызвать аварийную остановку программы).</li>
			  <li>Некорректно сравнивать в программе вещественные числа на точное равенство.</li>
			  </ol>
			  
			  <h3><a name="v" class="anchor"></a>Вопросы и задачи для самопроверки</h3>
			  
			  <OL>
				<P>
				<LI>Записать в нормализованном виде числа 0,0017<SUB>10</SUB>; 100,01<SUB>2</SUB>;
				  1043,24<SUB>5</SUB>.</LI>
				<p></P>
				<P>
				<LI>Записать в k разрядов мантиссу числа 0,3<SUB>10</SUB> при k=8,10.
				  Результаты перевести в десятичную с.с., округлив при этом до 5 знаков,
				  и сравнить с точным значением.</LI>
				<p></P>
				<P>
				<LI>Вычислить сумму и разность чисел а и b, используя <B>компьютерный
				  алгоритм</B> сложения и вычитания: а = 10<SUB>2</SUB> и b = 0,011<SUB>2</SUB>.</LI>
				<p></P>
				<P>
				<LI>Вычислить сумму чисел а = 0,0000000001 и b=110, если под мантиссу
				  отведено 8 разрядов, используя <B>компьютерный алгоритм</B> сложения.</LI>
				<p></P>
				<P>
				<LI>Вычислить, используя <B>компьютерный алгоритм</B> вычитания, а – b,
				  а=0,1(011); b=0,1011 сначала без учета разрядности мантиссы, затем при
				  8-ми отведенных под мантиссу разрядах. Мантиссу разности перевести в
				  десятичную с.с.</LI>
				<p></P>
				<P>
				<LI>Вычислить, используя <B>компьютерный алгоритм</B> умножения, 101,1<SUB>2
				  &#180; </SUB> 1010<SUB>2</SUB>.</LI>
				<p></P>
				<P>
				<LI>Вычислить, используя <B>компьютерный алгоритм</B> деления, 1101110<SUB>2
				  </SUB>: 1011<SUB>2</SUB>.</LI>
				<p></P>
				<P>
				<LI>Пусть для представления числа отведены следующие разряды: k<SUB>m</SUB>=
				  8 бит, k<SUB>q</SUB>=4 бита, 1 бит под знак. При этом расположение разрядов
				  как в типе REAL, и старшая единица также не пишется в мантиссу. Найти:
				  1) сдвиг порядка; 2) машинный ноль; 3) максимальное положительное число;
				  4) число 1111111110000.</LI>
				<p></P>
				<P>
				<LI>Пусть k<SUB>m</SUB>=8 бит, k<SUB>q</SUB>= 4 бита; а= 0,111111<SUB>2</SUB>;
				  b= 111,1<SUB>2</SUB> &#215; 2<SUP>-9</SUP>. При этом расположение разрядов
				  как в типе REAL, и старшая единица также не пишется в мантиссу. Вычислить
				  a+b, используя “компьютерный” алгоритм. Сравнить результат с точным
				  значением. Записать вычисленный результат в отведенные биты.</LI>
			
			
			
			
			
			</div>
		</div>
	</div>
</div>
	 <!--Меню навигации по Темам-->
	<div aria-label="..." class = "nav-menu">
		<ul class="pager  background-transition-slow" >
			 <li title="Наверх" style = "margin-right:15px;	"><a class = "glyphicon glyphicon-menu-up page-scroll" href="#page-top" ></a></li>
			 <li title="К предыдущей лекции"><a class = "glyphicon glyphicon-menu-left page-scroll" href="lii_4.html" ></a></li>
			 <li title="В содержание"><a class = "glyphicon glyphicon-list-alt" href="lec_index.html" ></a></li>
			 <li title="К следующей лекции"><a class = "glyphicon glyphicon-menu-right page-scroll" href="lii_6.html" ></a></li>
		</ul>
	</div>
 
 
 <!-- jQuery -->
 <script src="../lib/js/jquery.js"></script>

 <!-- Bootstrap Core JavaScript -->
 <script src="../lib/js/bootstrap.min.js"></script>

 <!-- Scrolling Nav JavaScript -->
 <script src="../lib/js/jquery.easing.min.js"></script>
 <script src="../lib/js/scrolling-nav.js"></script>

</body>

</html>