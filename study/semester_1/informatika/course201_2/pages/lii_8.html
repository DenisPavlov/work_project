<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="do.sibsutis.ru">

  <title>Информатика</title>
	
	<link rel="icon" type="image/png" href="../lib/css/favicon.png">
  <!-- Bootstrap Core CSS -->
  <link href="../lib/css/bootstrap.css" rel="stylesheet">
	
  <!-- Custom CSS -->
  <link href="../lib/css/scrolling-nav.css" rel="stylesheet">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>

<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top" data-spy="scroll" data-target=".navbar-fixed-top">
  <!-- Navigation -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
  <!-- Brand and toggle get grouped for better mobile display -->
 
 <div class="navbar-header">
 
  <li class="hidden"> <a class="page-scroll" href="#page-top"></a> </li>
	 
	
 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
   </button>
	 
   <a class="navbar-brand " href="../index.html"> 
  <text class = "hidden-xs">Информатика</text> 
  <text class = "visible-xs">Информатика</text>
</a>
  </div>

 
 <!-- Collect the nav links, forms, and glyphicon glyphicon-list-alt content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
   
	  
 <ul class="nav navbar-nav navbar-right">
   
 <li class="dropdown">
		<button type="button" class="navbar-toggle dropdown-toggle hidden-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>	   
		<a class = "dropdown-toggle visible-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Материалы</a>
    
	<ul class="dropdown-menu">
	
		<li><a href="../index.html">Аннотация курса</a></li>
	
		<li role="separator" class="divider"></li>
	
		<li><a href="lec_index.html">Теория</a></li>
		<li><a href="labs.html">Лабораторные работы</a></li>
		<li><a href="c_work.html">Контрольная работа</a></li>
		
		<li role="separator" class="divider"></li>
		
		<li><a href="lit.html">Литература</a></li>


 
    </ul>
 
</li>
 </ul>
  </div><!-- /.navbar-collapse -->
 </div><!-- /.container-fluid -->
</nav>


<div id="intro" class="section content-section ">
    <div class="container">
		<div class="row">
			<div class="col-lg-12">	
				
			<div class="page-header">
				<h3>8. Сжатие данных</h3>
				<a href="lii_8.html#8_1" class="punkt">8.1 Алгоритмы обратимых методов. Алгоритм RLE (Run–Length Encoding)</a> 
			</div>
			
			
			
			
			<P>&#9;Рассмотрим общую схему передачи информации:</P>
			  
			  <p><img src="img/sx8_1.gif" width="500" height="61"></p>
			  
			  <p>Если речь идёт о хранении данных, то в этой схеме между каналом связи 
				и декодирующим устройством появляется ещё два этапа: </p>
			  <p><img src="img/sx8_2.gif" width="219" height="69"></p>
			  
			  <P>&#9;Как хранение, так и передача информации обходятся 
				участникам информационного процесса недёшево. В связи с этим регулярно 
				возникает необходимость сжимать данные перед тем, как размещать их в архивах 
				или передавать по каналам связи.</P>
			  <P>&#9;Характерной особенностью большинства “классических” 
				типов данных, с которыми традиционно работают люди, является определённая 
				избыточность. Степень избыточности зависит от типа данных: например, у 
				видео данных степень избыточности обычно выше в несколько раз, чем у графических 
				данных, а степень избыточности графических данных в несколько раз выше, 
				чем у текстовых. Кроме того, степень избыточности зависти от принятой 
				системы кодирования. Для человека избыточность информации часто связана 
				с представлением о её качестве. А вообще-то для неё есть и математическое 
				определение.</P>
			  <P>&#9;Несмотря на изобилие алгоритмов сжатия данных, теоретически 
				есть только три способа уменьшения их избыточности: либо изменение содержания 
				данных, либо изменение их структуры, либо и то, и другое вместе.</P>
			  <P>&#9;Если при сжатии данных происходит изменение их содержания, 
				метод сжатия необратим и при восстановлении данных не происходит полного 
				восстановления исходной последовательности. Такие методы называют также 
				<B>методами сжатия с регулируемой потерей информации</B>. Естественно, 
				они применимы не ко всем типам данных: их нельзя применять к текстовым 
				документам, базам данных, и, тем более, к программному коду. Такие методы 
				применяют к мультимедийным данным: видеоряду, музыкальным записям, звукозаписям 
				и рисункам. Характерными форматами сжатия с потерей информации являются:</P>
			  <P>&#9;.JPG – для графических данных;</P>
			  <P>&#9;.MPG – для видео данных;</P>
			  <P>&#9;.MP3 – для звуковых данных;</P>
			  <P>Методы сжатия <strong>с </strong>регулируемой потерей информации дают очень хороший эффект сжатия.</P>
			  <P>&#9;Если при сжатии данных происходит только изменение 
				их структуры, то метод сжатия <B>обратим</B>. Обратимые методы применяются 
				к любым типам данных. Характерными форматами сжатия без потери информации 
				являются:</P>
			  <P>&#9;.GIF, .TIFF, .PCX и многие другие – для графических 
				данных.</P>
			  <P>&#9;.AVI – для видеоданных.</P>
			  <P>&#9;.ZIP, .ARJ, .RAR, .LZH, .LH, .CAB и многие другие 
				– для любых типов данных. </P>
			  <P>&#9;При обсуждении эффективности методов сжатия следует 
				иметь в виду существование следующих доказанных теорем:</P>
			   
			  <P>1. Для любой последовательности данных существует теоретический 
				предел сжатия, который не может быть превышен без потери части информации.</P>
			  <P>2. Для любого алгоритма сжатия можно указать такую последовательность 
				данных, для которой он обеспечит лучшую степень сжатия, чем другие методы.</P>
			  <P>3. Для любого алгоритма сжатия данных можно указать такую 
				последовательность данных, для которой данный алгоритм вообще не позволит 
				получить сжатия.</P>
			  <P></P>
			  
			  <P>Из 2 и 3 следует, что оценивать эффективность алгоритмов 
				сжатия достаточно сложно. Наивысшую эффективность они демонстрируют для 
				данных разных типов и разных объёмов. Существует много обратимых методов 
				сжатия данных, но в их основе лежит небольшое количество теоретических 
				алгоритмов. Коротко рассмотрим три из них: RLE, KWE и алгоритм Хаффмана.</P>
			  
			  <h3><a name="8_1" class="anchor"></a>8.1 Алгоритмы обратимых методов.</h3>
			  <div><B>Алгоритм RLE</B> (Run–Length Encoding)</div>
			  <P>&#9;В основу подобных алгоритмов положен принцип выявления 
				повторяющихся последовательностей данных и замены их простой структурой, 
				в которой указывается код данных и коэффициент повтора.</P>
			  <P>&nbsp;</P>
			  <P><B>Пример</b> 1. Исходная последовательность: 0;0;0;127;127;0;255;255;255;255. 
				Исходная последовательность занимает 10 байт памяти.</P>
			  <P>Для неё строится следующая структура:</P>
			  <P></P>
			  <P>
			  
				<TABLE BORDER CELLSPACING=1 CELLPADDING=3 WIDTH=336>
				  <TR> 
					<TD WIDTH="50%" VALIGN="TOP" HEIGHT=31> <div>Значение</div></TD>
					<TD WIDTH="50%" VALIGN="TOP" HEIGHT=31> <div>Коэффициент 
						повтора</div></TD>
				  </TR>
				  <TR> 
					<TD WIDTH="50%" VALIGN="TOP" HEIGHT=31> <div>0</div></TD>
					<TD WIDTH="50%" VALIGN="TOP" HEIGHT=31> <div>3</div></TD>
				  </TR>
				  <TR> 
					<TD WIDTH="50%" VALIGN="TOP" HEIGHT=31> <div>127</div></TD>
					<TD WIDTH="50%" VALIGN="TOP" HEIGHT=31> <div>2</div></TD>
				  </TR>
				  <TR> 
					<TD WIDTH="50%" VALIGN="TOP" HEIGHT=31> <div>0</div></TD>
					<TD WIDTH="50%" VALIGN="TOP" HEIGHT=31> <div>1</div></TD>
				  </TR>
				  <TR> 
					<TD WIDTH="50%" VALIGN="TOP" HEIGHT=31> <div>255</div></TD>
					<TD WIDTH="50%" VALIGN="TOP" HEIGHT=31> <div>4</div></TD>
				  </TR>
				</TABLE>
			  
			  
			  <P>После кодирования исходная последовательность будет иметь 
				вид: 0;3;127;2;0;1;255;4.</P>
			  <P>Т.е сначала идёт значение, за ним – сколько раз это значение 
				требуется повторить. После кодирования памяти требуется 8 байт.</P>
			  <P> Наилучшие объекты для такого алгоритма – графические 
				файлы, в которых есть большие одноцветные участки. Для текстовых данных 
				методы RLE, как правило, не эффективны.</P>
			  <P></P>
			  <p>&nbsp;</p>
			  <div><B>Алгоритм KWE</b> (Keyword Encoding)</div>
			  <P></P>
			  <P>Алгоритм кодирования по ключевым словам. В его основу 
				положено кодирование лексических единиц группами байтов фиксированной 
				длины. Чаще всего лексической единицей является слово. Результат кодирования 
				сводится в таблицу, которая прикладывается к результирующему коду, и представляет 
				собой словарь. Обычно для англоязычных текстов принято использовать двухбайтную 
				кодировку (пара байтов в этих алгоритмах называется “токен”).</P>
			  <P>Эффективность данного метода зависит от длины документа, 
				поскольку из-за необходимости прикладывать к архиву словарь, длина кратких 
				документов не только не уменьшается, а даже возрастает.</P>
			  <P>Этот алгоритм наиболее эффективен для англоязычных текстов 
				и файлов баз данных. Для русскоязычных документов, отличающихся большой 
				длиной слов, большим количеством суффиксов, приставок и окончаний, не 
				всегда возможно ограничиться двухбайтными токенами, и эффективность метода 
				заметно снижается.</P>
			  <P></P>
			  <p>&nbsp;</p>
			  <div><b>Код Хаффмана</b></div>
			  <P>&nbsp;</P>
			  <P>&#9;В основе этого алгоритма лежит кодирование не байтами, 
				а битовыми группами. Дело в том, что в реальных алфавитах какие-то символы 
				встречаются чаще, какие-то реже. Идея алгоритма проста: надо часто встречающиеся 
				символы кодировать более короткими словами, а реже встречающиеся – длинными 
				словами.</P>
			  <P>&#9;Перед началом кодирования проводится частотный анализ 
				текста и определяется частота повтора всех встречающихся символов. </P>
			  <P>&nbsp;</P>
			  <P><B>Пример 2</b>. Пусть в алфавите всего 5 символов: А<SUB>0</SUB>= 
				{а, б, в, г, д}. После анализа выяснилось, что частота появления этих 
				символов соответственно К<SUB>1</SUB>=30, К<SUB>2</SUB>=10, К<SUB>3</SUB>=25, 
				К<SUB>4</SUB>=25, К<SUB>5</SUB>=10, а сам текст состоит из 100 символов. 
				Вычислим относительные частоты: <IMG SRC="img/Image1678.gif" WIDTH=30 HEIGHT=53 align="absmiddle">, 
				где N – общее количество символов. </P>
			  <P>Для нашего примера они соответственно 0,3; 0,1; 0,25; 
				0,25; 0,1.</P>
			  <P>&#9;Теперь исходный алфавит надо упорядочить по убыванию 
				относительных частот: А<SUB>1</SUB>={а, в, г, б, д }. (см. рисунок 4):</P>
				<p>Сначала объединим вместе два самых редких символа – «б» и «д» (рис. 4). Верхнему припишем <font color="#FF0000"><b>0</b></font>, нижнему – <font color="#FF0000"><b>1</b></font>. У нас появился новый алфавит, в котором символы «б» и «д» считаются одним символом  (обозначим его «б1») с  относительной частотой 0,1+0,1=0,2.</p>
				<p>Теперь объединим вместе два более редких символа нового алфавита, «б1» и, к примеру, «г». Верхнему приписываем <font color="#FF0000"><b>0</b></font>, нижнему <font color="#FF0000"><b>1</b></font>.  Теперь они считаются одним символом с относительной частотой 0,2+0,25=0,45. Опять находим два символа с наименьшими частотами и объединяем их в один. Теперь это символы «а» и «в». Верхнему приписываем <font color="#FF0000"><b>0</b></font>, нижнему <font color="#FF0000"><b>1</b></font>. Их суммарная относительная частота 0,3+0,25=0,55. Осталось объединить последние два символа, верхнему приписываем <font color="#FF0000"><b>0</b></font>, нижнему <font color="#FF0000"><b>1</b></font>.</p>
			  <P>&nbsp;</P>
			  <P><img src="img/pic8_4.gif" width="382" height="254"></P>
			  <div>Рисунок 4. Построение кода Хаффмана.&nbsp;</div>
			  <P>&nbsp;</P>
			  
			  <P>Код символа получается из последовательности нулей и 
				единиц при движении по этому дереву справа налево к каждому символу. На 
				рисунке получившиеся коды символов выделены зелёным цветом.</P>
			  <P>&#9;Попробуем декодировать последовательность 1111111000:</P>
			  <P><img src="img/Image1679.gif" width="117" height="48">.&#9;</P>
			  <P>&nbsp;</P>
			  <P>Т.е. при декодировании получим “гдба”.</P>
			  <P>Код Хаффмана однозначно декодируем. Он относится к префиксным 
				кодам. (<U>Определение</U> префиксного кода – в нём ни одно кодовое слово 
				не является началом другого кодового слова).</P>
			  <P>Вообще говоря, образующаяся иерархическая структура должна 
				прикладываться к закодированному тексту. Следовательно, для небольших 
				текстов в таком кодировании выгоды нет никакой. Этот алгоритм даёт эффект 
				при больших объёмах информации.</P>
			  <P>&#9;Код Хаффмана оптимален в том смысле, что у него наименьшая 
				средняя длина кодового слова.</P>
			  
			  <P>&nbsp;</P>
			  <div><b>Код Фано (Шеннона-Фано)</b></div>
			  <p>Был разработан Шенноном и Фано независимо друг от друга в 1948-49 г. Близок по построению к коду Хаффмана.</p>
			  <p>Алгоритм (возможны варианты):</p>
			  <ol>
			  <li>Документ просматривается для определения частот всех встречающихся символов.</li>
			  <li>Выписывают символы в порядке возрастания относительных частот.</li>
			  <li>Множество символов последовательно делят на два подмножества так, чтобы сумма относительных частот одного подмножества была приблизительно равна сумме относительных частот второго. Для левого подмножества каждому символу приписывают «0», для правого – «1». Дальнейшие разбиения повторяются до тех пор, пока все подмножества не будут состоять из одного элемента.</li>
			  </ol>
			  <p>&nbsp;</p>
			  <p><b>Пример 3</b>. Проведём кодирование текста из примера 2 методом Фано (см. рисунок 5)</p>
			  <div><img src="img/image439.gif"></img></div>
			  <div>Рисунок 5. Построение кода Фано.</div>
			  <p>Код символа получается движением от корня к листьям. В результате получим следующие коды символов:</p>
			  <p>а – 11;</p>
			  <p>в – 10;</p>
			  <p>г – 01;</p>
			  <p>б – 001;</p>
			  <p>д – 000;</p>
			  <p>Говорят, что алгоритм создания кода Хаффамана « снизу-вверх», а кода Фано «сверху-вниз». Достоинство этих кодов – простота реализации, недостаток – не оптимальность в общем случае. Эти алгоритмы часто используются в графических форматах, при этом кодируются не отдельные символы, а целые байты. К примеру, разновидность алгоритма Хаффмана используется в качестве последнего этапа архивации в JPEG, как составная часть архивации – в TIFF.</p>
			  <p>В реальной жизни эти алгоритмы в чистом виде не применяются. Используют различные их комбинации. Общий принцип – предварительный просмотр и анализ документа для индивидуальной настройки алгоритма.</p> 
			
			
			
			
			</div>
		</div>
	</div>
</div>
	 <!--Меню навигации по Темам-->
	<div aria-label="..." class = "nav-menu">
		<ul class="pager  background-transition-slow" >
			 <li title="Наверх" style = "margin-right:15px;	"><a class = "glyphicon glyphicon-menu-up page-scroll" href="#page-top" ></a></li>
			 <li title="К предыдущей лекции"><a class = "glyphicon glyphicon-menu-left page-scroll" href="lii_7.html" ></a></li>
			 <li title="В содержание"><a class = "glyphicon glyphicon-list-alt" href="lec_index.html" ></a></li>
			 <!--li title="К следующей лекции"><a class = "glyphicon glyphicon-menu-right page-scroll" href="lii_8.html" ></a></li-->
		</ul>
	</div>
 
 
 <!-- jQuery -->
 <script src="../lib/js/jquery.js"></script>

 <!-- Bootstrap Core JavaScript -->
 <script src="../lib/js/bootstrap.min.js"></script>

 <!-- Scrolling Nav JavaScript -->
 <script src="../lib/js/jquery.easing.min.js"></script>
 <script src="../lib/js/scrolling-nav.js"></script>

</body>

</html>