<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="do.sibsutis.ru">

  <title>Информатика</title>
	
	<link rel="icon" type="image/png" href="../lib/css/favicon.png">
  <!-- Bootstrap Core CSS -->
  <link href="../lib/css/bootstrap.css" rel="stylesheet">
	
  <!-- Custom CSS -->
  <link href="../lib/css/scrolling-nav.css" rel="stylesheet">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>

<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top" data-spy="scroll" data-target=".navbar-fixed-top">
  <!-- Navigation -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
  <!-- Brand and toggle get grouped for better mobile display -->
 
 <div class="navbar-header">
 
  <li class="hidden"> <a class="page-scroll" href="#page-top"></a> </li>
	 
	
 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
   </button>
	 
   <a class="navbar-brand " href="../index.html"> 
  <text class = "hidden-xs">Информатика</text> 
  <text class = "visible-xs">Информатика</text>
</a>
  </div>

 
 <!-- Collect the nav links, forms, and glyphicon glyphicon-list-alt content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
   
	  
 <ul class="nav navbar-nav navbar-right">
   
 <li class="dropdown">
		<button type="button" class="navbar-toggle dropdown-toggle hidden-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>	   
		<a class = "dropdown-toggle visible-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Материалы</a>
    
	<ul class="dropdown-menu">
	
		<li><a href="../index.html">Аннотация курса</a></li>
	
		<li role="separator" class="divider"></li>
	
		<li><a href="lec_index.html">Теория</a></li>
		<li><a href="labs.html">Лабораторные работы</a></li>
		<li><a href="c_work.html">Контрольная работа</a></li>
		
		<li role="separator" class="divider"></li>
		
		<li><a href="lit.html">Литература</a></li>


 
    </ul>
 
</li>
 </ul>
  </div><!-- /.navbar-collapse -->
 </div><!-- /.container-fluid -->
</nav>


<div id="intro" class="section content-section ">
    <div class="container">
		<div class="row">
			<div class="col-lg-12">	
				
			<div class="page-header">
				<h3>4. Представление целых чисел в компьютере</h3>
		
				<a href="lii_4.html#4_1" class="punkt">4.1 Представление положительных чисел в беззнаковых целых типах</a>
				<br>
				<a href="lii_4.html#4_2" class="punkt">4.2 Представление положительных и отрицательных чисел в знаковых целых типах</a>
				<br>
				<a href="lii_4.html#4_3" class="punkt">4.3 Арифметические действия в ограниченном количестве разрядов</a>
				<br>
				<a href="lii_4.html#v" class="punkt">Вопросы и задачи для самопроверки</a>
				<br>
			</div>
			
			
			
			
			<P>&#9;Простейшими типами данных, с которыми оперируют компьютеры, 
			являются целые числа. Казалось бы, что, так как любое число является и 
			вещественным, но с нулевой дробной частью, то и достаточно наличия только 
			вещественных типов данных. Необходимость разных типов вызвана тем, что 
			скорость выполнения операций над данными целого типа значительно выше, 
			чем скорость выполнения этих же операций над данными вещественного типа. 
			При этом существует большой класс задач, например, экономического характера, 
			при решении которых данными служат именно целые числа. Целые числа используются 
			в программировании для нумерации различных объектов: элементов массивов, 
			записей в базах данных, машинных адресов в памяти компьютера. Текстовая, 
			графическая и звуковая информация кодируется в компьютере с помощью именно 
			целых чисел.</P>
		  <P>Для компьютерного представления целых чисел обычно используется 
			несколько различных типов данных, отличающихся друг от друга количеством 
			разрядов и наличием или отсутствием знакового разряда.</P>
		  <a name="4_1" class="anchor"></a>
		  <h3>4.1 Представление положительных чисел в беззнаковых 
			целых типах</h3>
		  
		  <P>&#9;В памяти компьютера под целое число выделяется несколько 
			двоичных разрядов (8, 16 или 32 &#8722; 1, 2, 4 байта). Эта группа разрядов 
			называется <B><I>ячейкой памяти</i></B>.</P>
		  <P>&#9;Биты в этой ячейке нумеруются справа налево, начиная 
			с нуля. Число переводится в двоичную систему счисления и записывается 
			в ячейку памяти, причём номера разрядов соответствуют степеням двойки:</P>
		  <P>&nbsp;</P>
		  <P><B>Пример</b> <B>1</B>: Запишем число 125 в 8-ми разрядную ячейку памяти:<br>
			<IMG SRC="img/Image1547.gif" WIDTH=554 HEIGHT=28></P>
		  <P></P>
		  <P> 
		  
			<TABLE BORDER CELLSPACING=1 CELLPADDING=1 WIDTH=247>
			  <TR> 
				<TD WIDTH="13%" VALIGN="TOP" HEIGHT=9> <P>7</TD>
				<TD WIDTH="13%" VALIGN="TOP" HEIGHT=9> <P>6</TD>
				<TD WIDTH="13%" VALIGN="TOP" HEIGHT=9> <P>5</TD>
				<TD WIDTH="13%" VALIGN="TOP" HEIGHT=9> <P>4</TD>
				<TD WIDTH="13%" VALIGN="TOP" HEIGHT=9> <P>3</TD>
				<TD WIDTH="13%" VALIGN="TOP" HEIGHT=9> <P>2</TD>
				<TD WIDTH="13%" VALIGN="TOP" HEIGHT=9> <P>1</TD>
				<TD WIDTH="13%" VALIGN="TOP" HEIGHT=9> <P>0</TD>
			  </TR>
			  <TR> 
				<TD WIDTH="13%" VALIGN="TOP" HEIGHT=25> <P><b>0</b></TD>
				<TD WIDTH="13%" VALIGN="TOP" HEIGHT=25> <P><b>1</b></TD>
				<TD WIDTH="13%" VALIGN="TOP" HEIGHT=25> <P><b>1</b></TD>
				<TD WIDTH="13%" VALIGN="TOP" HEIGHT=25> <P><b>1</b></TD>
				<TD WIDTH="13%" VALIGN="TOP" HEIGHT=25> <P><b>1</b></TD>
				<TD WIDTH="13%" VALIGN="TOP" HEIGHT=25> <P><b>1</b></TD>
				<TD WIDTH="13%" VALIGN="TOP" HEIGHT=25> <P><b>0</b></TD>
				<TD WIDTH="13%" VALIGN="TOP" HEIGHT=25> <P><b>1</b></TD>
			  </TR>
			</TABLE>
		  
		  <p></P>
		  <P></P>
		  <P>&#9;Т.к. мы сейчас говорим только о положительных числах, 
			нам не надо как-то записывать знак числа. Следовательно, все разряды можно 
			отводить под представление самой величины числа.</P>
		  <DIR> 
		  <P>Такое представление называется с <B><I>фиксированной 
			запятой</i></B>, т.к. запятая всегда находится на одном и том же месте 
			– после младшего (правого) разряда (вне разрядной сетки).</P>
		  <P></P>
		  </DIR>
		  <P>Определим диапазон чисел, которые мы можем таким образом 
			представить.</P>
		  <P>Если количество разрядов n = 8, то наименьшее число выглядит 
			как 0000 0000<SUB>2</SUB> , а наибольшее выглядит как 1111 1111<SUB>2 
			</SUB>, т.е. min = 0, max = <IMG SRC="img/Image1548.gif" WIDTH=50 HEIGHT=26 align="absmiddle">= 
			255.</P>
		  <P>&#9;Если необходимо записывать числа большей величины, 
			надо увеличить разрядность ячейки. В таблице 4 приведены некоторые беззнаковые 
			целые типы языков TURBO PASCAL и C. Заметим, что в С размер того или иного 
			типа может отличаться в различных компиляторах языка.</P>
		  <P>&nbsp;</P>
		  <P></P>
		  <P>Таблица 4. Беззнаковые типы.</P>
		  <P>&nbsp;</P>
		  <TABLE BORDER CELLSPACING=1 CELLPADDING=1 WIDTH=500>
			<TR> 
			  <TD WIDTH="24%" VALIGN="TOP" HEIGHT=38> Кол-во бит</TD>
			  <TD WIDTH="28%" VALIGN="TOP" HEIGHT=38> Max. значение</TD>
			  <TD WIDTH="26%" VALIGN="TOP" HEIGHT=38> Название в TP</TD>
			  <TD WIDTH="22%" VALIGN="TOP" HEIGHT=38> Название в С</TD>
			</TR>
			<TR> 
			  <TD WIDTH="24%" VALIGN="TOP" HEIGHT=38> <div>8</div></TD>
			  <TD WIDTH="28%" VALIGN="TOP" HEIGHT=38> 255 (<IMG SRC="img/Image1549.gif" WIDTH=50 HEIGHT=26 align="absmiddle">)</TD>
			  <TD WIDTH="26%" VALIGN="TOP" HEIGHT=38> <div>byte</div></TD>
			  <TD WIDTH="22%" VALIGN="TOP" HEIGHT=38> <div>Unsigned 
				  char</div></TD>
			</TR>
			<TR> 
			  <TD WIDTH="24%" VALIGN="TOP" HEIGHT=38> <div>16</div></TD>
			  <TD WIDTH="28%" VALIGN="TOP" HEIGHT=38> 65535 (<IMG SRC="img/Image1550.gif" WIDTH=57 HEIGHT=26 align="absmiddle">)</TD>
			  <TD WIDTH="26%" VALIGN="TOP" HEIGHT=38> <div>word</div></TD>
			  <TD WIDTH="22%" VALIGN="TOP" HEIGHT=38> <div>Unsigned 
				  short </div></TD>
			</TR>
			<TR> 
			  <TD WIDTH="24%" VALIGN="TOP" HEIGHT=38> <div>32</div></TD>
			  <TD WIDTH="28%" VALIGN="TOP" HEIGHT=38> 4&nbsp;294&nbsp;967&nbsp;295 
				<br>
				(<IMG SRC="img/Image1551.gif" WIDTH=58 HEIGHT=26 align="absmiddle">)</TD>
			  <TD WIDTH="26%" VALIGN="TOP" HEIGHT=38> <div>&#8722;//&#8722;*</div></TD>
			  <TD WIDTH="22%" VALIGN="TOP" HEIGHT=38> <div>Unsigned 
				  long</div></TD>
			</TR>
		  </TABLE>
		  <p>&nbsp;</p>
		  <P>* в Delphi есть Cardinal (31 бит занимает)</P>
		  <P></P>
		  <DIR>
		  <P><B>В общем случае, если под целое беззнаковое число выделено 
			n двоичных разрядов, то минимальное представимое в такой ячейке памяти 
			число равно 0, а максимальное равно &#9;2<SUP>n</SUP>-1.</b></P>
		  <P></P>
		  </DIR>
		  <P>Выделение беззнаковых типов в отдельную группу объясняется 
			тем, что в ячейках одного и того же размера в беззнаковом типе можно представить 
			больше различных положительных чисел, чем в знаковом.</P>
		  
		  <h3><a name="4_2" class="anchor"></a>4.2 Представление положительных и 
			отрицательных чисел в знаковых целых типах.</h3>
		  
		  <P>&#9;Целые положительные числа можно представлять и в 
			знаковых типах данных. В них самый левый разряд числа отводится под запись 
			знака (0–для положительных чисел, 1– для отрицательных), остальные разряды 
			заняты двоичным представлением числа. </P>
		   
		  <P><I><B>Прямой код</b></i> &#8722; представление числа 
			в привычном виде “знак” &#8722; “величина”, при котором старший разряд 
			ячейки отводится под знак, а остальные разряды ячейки под запись модуля 
			числа.</P>
		  
		  <P><I><B>Алгоритм представления целых положительных чисел 
			в виде прямого кода</b></i>:</P>
		  <OL>
			<P> 
			<LI>целое положительное число, входящие в диапазон допустимых значений 
			  того или иного типа, переводится в двоичную систему счисления.</LI>
			<p></P>
			<P> 
			<LI>Двоичное число дополняется, если это необходимо, слева нулями до соответствующего 
			  числа разрядов (8,16,32).</LI>
			<p></P>
			<P> 
			<LI>Полученное число записывается в ячейку так, что в самом левом разряде 
			  размещается самая старшая цифра, а в правом младшая.</LI>
			<p></P>
		  </OL>
		  <P><B>Пример 2.</b> Запишем число 53 в 8-ми разрядную ячейку 
			памяти:</P>
		  <P><IMG SRC="img/Image1552.gif" WIDTH=110 HEIGHT=38> <IMG SRC="img/Image1553.gif" WIDTH=285 HEIGHT=32></P>
		  <P>Т.к. выделено 8 разрядов, а запись числа занимает 6, 
			требуется дополнить запись числа двумя нулями слева. В результате получим:</P>
		  <P> <img src="img/ff.gif" width="95" height="40"></P>
		  <P> Ноль в старшем (левом) разряде говорит о том, что число 
			положительное. Если это же число записать в 16-ти разрядную ячейку памяти, 
			то получим: </P>
		  <P><img src="img/ff2.gif" width="186" height="40"></P>
		  <P></P>
		  <P>Определим диапазон чисел, представимых подобным образом. 
			Т.к. из n двоичных разрядов под запись величины числа остаётся только 
			(n-1) разряд, следовательно, максимальное положительное число выглядит 
			как</P>
		  <P><i> </i></P>
		  <P ALIGN="LEFT"> 
		  <TABLE WIDTH=184>
			<TR>
			  <TD VALIGN="TOP" HEIGHT=24><i>знак</i></TD>
			  <TD VALIGN="TOP" HEIGHT=24>&nbsp;</TD>
			</TR>
			<TR> 
			  <TD WIDTH="13%" VALIGN="TOP" HEIGHT=24> 0</TD>
			  <TD WIDTH="87%" VALIGN="TOP" HEIGHT=24> 11. . . . . . . . . . 1</TD>
			</TR>
			<TR> 
			  <TD HEIGHT=64 colspan="2" VALIGN="TOP"><img src="img/Image1556.gif" width=170 height=48></TD>
			</TR>
		  </TABLE>
		  <p></P>
		  <P>&nbsp; </P>
		  <P>и равно <IMG SRC="img/Image1557.gif" WIDTH=66 HEIGHT=26>.</P>
		  <P>&nbsp;</P>
		  <P><B>Пример 3</b>. Пусть n=8; 128<SUB>10</SUB> = <IMG SRC="img/Image1558.gif" WIDTH=24 HEIGHT=26>= 
			1000 0000<SUB>2</SUB>. Если записать такое число в заданную ячейку памяти, 
			получим 1 в знаковом разряде, что трактуется как отрицательное число. 
			Это случилось из-за того, что <IMG SRC="img/Image1559.gif" WIDTH=237 HEIGHT=28 align="absmiddle">.</P>
		  <P></P>
		  <P>&#9;Как представить отрицательное число? Самый, казалось 
			бы, простой вариант – в старшем разряде поставить 1 (признак отрицательного 
			числа), а остальные разряды будут содержать запись модуля числа. Однако 
			тогда число ноль будет записываться двумя способами: к примеру, в 8-разрядной 
			ячейке, 1000 0000 (минус ноль) и 0000 0000 (плюс ноль).
		  Кроме того, проводить арифметические операции над такими 
			числами будет достаточно сложно. Представим, к примеру, что надо сложить 
			два числа, одно из которых положительное, а другое отрицательное. Сначала 
			придётся определить большее по модулю число, запомнить его знак. Затем 
			из большего модуля вычесть меньший модуль и поставить перед результатом 
			знак большего по модулю числа.</P>
		  <P>&#9;<B>Поэтому в настоящее время для записи отрицательных 
			чисел прямой код не используется. Для представления отрицательных чисел 
			используют дополнительный код.</b></P>
		  
		  <P><I><B>Дополнительный k-разрядный код отрицательного числа</b></i> 
			<I>m</I> &#8722; это запись в <I>k</I> разрядах положительного числа <IMG SRC="img/Image1560.gif" WIDTH=66 HEIGHT=34 align="absmiddle">, 
			где <IMG SRC="img/Image1561.gif" WIDTH=25 HEIGHT=32 align="absmiddle"> &#8722; модуль отрицательного 
			числа, на которое накладывается ограничение: <IMG SRC="img/Image1562.gif" WIDTH=81 HEIGHT=34 align="absmiddle">.</P>
		  <P><b>Дополнительный код положительного числа равен прямому 
			коду положительного числа.</b></P>
		  
		  <P><U>Пояснение</u>: если под число выделено k разрядов, 
			то число <IMG SRC="img/Image1563.gif" WIDTH=57 HEIGHT=28 align="absmiddle"> </P>
		  <P>(т.к. <IMG SRC="img/Image1565.gif" align="absmiddle">). 
			Т.о. дополнительный код отрицательного числа &#8722; это дополнение модуля 
			m до <IMG SRC="img/Image1566.gif" WIDTH=57 HEIGHT=28 align="absmiddle"> 
			<br>
			<IMG SRC="img/Image1567.gif" WIDTH=269 HEIGHT=34> 
		  <P>&nbsp; </p>
		  <div><strong>Алгоритм получения k-разрядного дополнительного 
			кода</strong><strong>отрицательного числа:</strong> </div>
		  <OL>
			<P> 
			<LI>Модуль числа представить прямым кодом в <I>k</I> двоичных разрядах.</LI>
			<p></P>
			<P> 
			<LI>Значения всех бит инвертировать (т.е. нули заменить на единицы, а 
			  единицы – на нули). Таким образом получается <I>k</I>-разрядный <B><I>обратный 
			  код</i></B> исходного числа.</LI>
			<p></P>
			<P> 
			<LI>K полученному обратному коду, трактуемому как <I>k</I>-разрядное неотрицательное 
			  двоичное число, прибавить единицу. </LI>
			<p></P>
		  </OL>
		  <P></P>
		  <P><B>Пример</b> <B>4</B>. Получим дополнительный код числа 
			<IMG SRC="img/Image1568.gif" WIDTH=50 HEIGHT=21 align="absmiddle"> для 8-разрядной ячейки 
			памяти.</P>
		  <P>1. Представим модуль числа прямым кодом в 8-ми разрядах:</P>
		  <P> <IMG SRC="img/Image1569.gif" align="absmiddle">; </P>
		  <P><B>0111 
			0101</B> &#8722; прямой код 117</P>
		  <P>2. Инвертируем: <B>1000 1010</B> &#8722; обратный код</P>
		  <P>3. Прибавляем единицу.</P>
		  <P></P>
		  <P><img src="img/exii4_4.gif" width="91" height="58"><B> 
			– </B>дополнительный код числа –117</P>
		  <P>Единица в старшем разряде показывает, что это отрицательное 
			число, записанное в дополнительном коде. Получим дополнительный код этого 
			же числа для 16-разрядной ячейки памяти:</P>
		  <P>&#9;<img src="img/exii4_4_2.gif" width="440" height="82"></P>
		  <P>Т.е. дополнительный код большей разрядности требует лишь 
			добавления единиц в старшие разряды.</P>
		  <P>Поговорим о диапазоне представляемых таким образом отрицательных 
			чисел. Фактически, при представлении отрицательного числа в дополнительном 
			коде, в старшем разряде записывается знак числа, а в остальных разрядах 
			записывается число <IMG SRC="img/Image1570.gif" WIDTH=81 HEIGHT=34 align="absmiddle">. 
			Если это число рассматривать как положительное (без знака), то максимальное 
			по модулю отрицательное число, которое можно представить в k разрядах, 
			равно <IMG SRC="img/Image1571.gif" WIDTH=54 HEIGHT=26 align="absmiddle">.</P>
		  <P><img src="img/exii4_4_3.gif" width="189" height="134"></P>
		  <P>&nbsp;</P>
		  <P></P>
		  <P><IMG SRC="img/Image1575.gif" WIDTH=288 HEIGHT=52></P>
		  <P><IMG SRC="img/Image1576.gif" WIDTH=418 HEIGHT=52></P>
		  <P>Т.е. <IMG SRC="img/Image1577.gif" WIDTH=112 HEIGHT=34 align="absmiddle"></P>
		  <P>&nbsp;</P>
		  <P></P>
		  <P><B>Пример 5.</b> Получим дополнительный код числа <I>m</I> 
			= –9 для 4-х разрядной ячейки.</P>
		  <P><img src="img/exii4_5.gif" width="146" height="95"></P>
		  <P>В знаковом разряде стоит 0, что соответствует <U>положительному</U> 
			числу. Ошибка произошла потому, что при записи числа в <I>k</I>-разрядном 
			дополнительном коде на модуль представляемого числа наложено ограничение: 
			<IMG SRC="img/Image1579.gif" WIDTH=81 HEIGHT=34 align="absmiddle">.</P>
		  <P> В нашем случае k = 4 <IMG SRC="img/Image1580.gif" WIDTH=121 HEIGHT=34 align="absmiddle">. 
			Т.е. нарушено условие применимости дополнительного кода.</P>
		  <P></P>
		  <P>В таблице 5 показаны диапазоны некоторых знаковых типов 
			языков TURBO PASCAL и С. </P>
		  <P>&nbsp;</P>
		  <P></P>
		  <P>Таблица 5. Знаковые типы</P>
		  <P></P>
		  <TABLE BORDER CELLSPACING=1 CELLPADDING=1 WIDTH=500>
			<TR> 
			  <TD WIDTH="14%" VALIGN="MIDDLE" HEIGHT=38> <div>Кол-во 
				  бит</div></TD>
			  <TD WIDTH="25%" VALIGN="MIDDLE" HEIGHT=38> <div>min значение</div></TD>
			  <TD WIDTH="22%" VALIGN="MIDDLE" HEIGHT=38> <div>max значение</div></TD>
			  <TD WIDTH="21%" VALIGN="MIDDLE" HEIGHT=38> <div>Название 
				  в TP</div></TD>
			  <TD WIDTH="18%" VALIGN="MIDDLE" HEIGHT=38> <div>Название 
				  в С</div></TD>
			</TR>
			<TR> 
			  <TD WIDTH="14%" VALIGN="MIDDLE" HEIGHT=38> 8</TD>
			  <TD WIDTH="25%" VALIGN="MIDDLE" HEIGHT=38> 128</TD>
			  <TD WIDTH="22%" VALIGN="MIDDLE" HEIGHT=38> 127</TD>
			  <TD WIDTH="21%" VALIGN="MIDDLE" HEIGHT=38> shortint</TD>
			  <TD WIDTH="18%" VALIGN="MIDDLE" HEIGHT=38> Char</TD>
			</TR>
			<TR> 
			  <TD WIDTH="14%" VALIGN="MIDDLE" HEIGHT=38> 16</TD>
			  <TD WIDTH="25%" VALIGN="MIDDLE" HEIGHT=38> &#8722; 32768</TD>
			  <TD WIDTH="22%" VALIGN="MIDDLE" HEIGHT=38> 32767</TD>
			  <TD WIDTH="21%" VALIGN="MIDDLE" HEIGHT=38> integer</TD>
			  <TD WIDTH="18%" VALIGN="MIDDLE" HEIGHT=38> short int</TD>
			</TR>
			<TR> 
			  <TD WIDTH="14%" VALIGN="MIDDLE" HEIGHT=38> 32</TD>
			  <TD WIDTH="25%" VALIGN="MIDDLE" HEIGHT=38> &#8722; 2&nbsp;147&nbsp;483 
				648</TD>
			  <TD WIDTH="22%" VALIGN="MIDDLE" HEIGHT=38> 2&nbsp;147&nbsp;483 647</TD>
			  <TD WIDTH="21%" VALIGN="MIDDLE" HEIGHT=38> longint</TD>
			  <TD WIDTH="18%" VALIGN="MIDDLE" HEIGHT=38> long int</TD>
			</TR>
		  </TABLE>
		  <p>&nbsp;</p><P></P>
		  <P>Следует отметить, что на современных компьютерах разрядность 
			процессора (число бит, допустимых для одновременной обработки) больше 
			или равна 4 байтам. Поэтому поддержка языками программирования целых типов 
			меньшего размера является данью прошлому: когда и разрядность процессора 
			была меньше, и в результате использования одного или двух байтных типов 
			удавалось экономить оперативную память при выполнении программы. Сейчас 
			использование 4-х байтных типов сделает программу, написанную для 32-х 
			разрядной операционной системы, более эффективной. Поэтому в Object Pascal 
			тип integer уже определён как 4-х байтовый. Во многих компиляторах языка 
			C тип int так же определён как 4-х байтовый.</P>
		  <P>&nbsp;</P>
		  <P> </P>
		  <div><b><i>Алгоритм получения десятичного числа по его дополнительному 
			коду:</i></b> </div>
		  <P><B>Вариант 1</b>. Проделать действия в обратном порядке:</P>
		  <P>1. Вычесть из числа 1.</P>
		  <P>2. Инвертировать значения всех бит.</P>
		  <P>3. Перевести полученное значение в десятичную с.с и <B>поставить 
			перед числом знак минус.</b></P>
		  <P> <B>Вариант 2. </b>Проделать те же действия, что и при 
			получении дополнительного кода. </P>
		  <P>1. Инвертировать дополнительный код.</P>
		  <P>2. Прибавить к полученному числу 1.</P>
		  <P>3. Перевести полученное значение в десятичную систему 
			счисления и <B>перед полученной записью поставить знак минус.</b></P>
		  <P></P>
		  <P><B>Пример 6</b>: Получить десятичное представление числа 
			1001 0111 по его дополнительному коду.</P>
		  <P>Вариант 1:</P>
		  <P>&nbsp; 1001 0111</P>
		   
		  <P> <U>- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
			&nbsp; 1</u></P>
		  <P> &nbsp;1001 0110 – вычли единицу</P>
		  <P> &nbsp;0110 1001 – инвертировали</P>
		  <P>&nbsp;</P>
		  <P>Вариант 2:</P>
		  <P>&nbsp; 1001 0111</P>
		  <P>&nbsp; 0110 1000 – инвертировали</P>
		  <P> +<U>&nbsp; &nbsp; &nbsp;</u><U>&nbsp; &nbsp; &nbsp;</u><U>&nbsp; 
			&nbsp; &nbsp;</u><U> </u><U> 1</u></P>
		  <P>&#9;&nbsp;&nbsp;0110 1001 – прибавили единицу</P>
		  <P> Результат получается одинаковый. Теперь переводим в 
			10-ю с.с:</P>
		  <P>0110 1001 = <IMG SRC="img/Image1581.gif" align="absmiddle">(т.к. 
			это был модуль отрицательного числа, не забываем поставить минус!)&#9;</P>
		  <P>&#9;</P>
		  <P>С какой целью отрицательные числа записывают в виде дополнительного 
			кода? С целью упрощения арифметических операций, т.к. вместо вычитания 
			положительных чисел <I>a</I> – <I>b</I>, выполняется сложение <I>а </I>+ 
			(–<I>b</I>) с числом, записанным в дополнительном коде. При этом знак 
			результата получается автоматически.</P>
		  <P>&nbsp;</P>
		  <P></P>
		  <P><B>Пример 7</b>. Вычислим (127 – 128) в 8-ми разрядной 
			ячейке памяти. Дополнительный код положительного числа равен его прямому 
			коду, следовательно,</P>
		  <P>127<SUB>10</SUB>= 111 1111 <SUB>2</SUB><IMG SRC="img/Image1582.gif" WIDTH=25 HEIGHT=18 align="absmiddle"> 
			прямой код числа 127 равен 0111 1111.</P>
		  <P>Найдём дополнительный код числа –128:</P>
		  <P><img src="img/exii4_7.gif" width="146" height="82"></P>
		  <P>&nbsp;</P>
		  <P>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;</P>
		  <P>складываем:&#9;</P>
		  <P><img src="img/exii4_7_2.gif" width="173" height="68"></P>
		  <P>– т.к. в знаковом разряде стоит 1, это отрицательное 
			число, записанное в доп. коде. Переводим:</P>
		  <P>&nbsp;</P>
		  <P> <img src="img/exii4_7_3.gif" width="238" height="95"></P>
		  <br>
		  <h3><a name="4_3" class="anchor"></a>4.3 Арифметические действия 
			в ограниченном количестве разрядов.</h3>
		 
		  <P>&#9;Умножение и деление в целочисленной двоичной арифметике 
			сводится к сложению и вычитанию, поэтому отдельно мы их рассматривать 
			не будем.</P>
		  <P>Если в обычной арифметике к любому числу прибавить единицу, 
			получится следующее число. Если, наоборот, отнять единицу, получится число 
			предыдущее. Наглядным представлением целых чисел будет прямая.</P>
		  <P>В компьютере для представления целого числа предоставляется 
			<I>k</I>-разрядная ячейка памяти. Пусть, для определённости, речь идёт 
			о беззнаковом типе данных, под который предоставлено 8 разрядов. Как уже 
			говорилось, самое маленькое число, представимое в такой ячейке равно 0, 
			а самое большое, которое выглядит как</P>
		  <P> 1111 1111, равно <IMG SRC="img/Image1583.gif" WIDTH=50 HEIGHT=26>=255.</P>
		  <P>Что произойдёт, если к этому числу прибавить 1?</P>
		  <P><img src="img/ii4_3.gif" width="109" height="67"></P>
		  <P> Т.к. старшая единица вышла за границу ячейки <IMG SRC="img/Image1582.gif" WIDTH=25 HEIGHT=18 align="absmiddle"> 
			<IMG SRC="img/Image1584.gif" WIDTH=124 HEIGHT=32 align="absmiddle">. Т.е. в 8-ми разрядной 
			арифметике 255+1=0. </P>
		  <P>В общем виде, если под число отведено <I>к</I> разрядов, 
			то 2<I><SUP>К</sup></I>+1=0.</P>
		  <P>Если мы рассмотрим знаковый тип данных, то минимальное 
			представимое в <I>k</I> разрядах число равно <IMG SRC="img/Image1585.gif" WIDTH=54 HEIGHT=26>, 
			а максимальное <IMG SRC="img/Image1586.gif" WIDTH=66 HEIGHT=26>.</P>
		  <P>Если к максимальному числу прибавить 1:</P>
		  <P><IMG SRC="img/Image1587.gif" WIDTH=164 HEIGHT=32 align="absmiddle">, это 
			число выглядит так:</P>
		  <P></P>
		  <P><img src="img/ii4_3_2.gif" width="207" height="111"></P>
		  <P>&nbsp; </P>
		  <P></P>
		  <P>Т.е. мы получим <U>отрицательное число</U>, причём максимальное 
			представимое в данном типе.</P>
		  <P>Поэтому наглядным представлением целых типов данных в 
			<I>k</I>–разрядной компьютерной арифметике является вовсе не числовая 
			ось, а <B><I>кольцо</i></B>, состоящее из расположенных по порядку констант 
			этого типа, причем рядом с максимальным значением в типе находится минимальное, 
			как показано на рисунке 1: </P>
		  <P></P>
		  <P><IMG SRC="img/Image1588.gif"></P>
		  <P></P>
		  <P>&nbsp;</P>
		  <P>&nbsp;</P>
		  <P>Рисунок 1. Арифметика в 8-ми разрядной ячейке памяти для 
			беззнакового и знакового типов.</P>
		  <P>&nbsp;</P>
		  <P>Результатом прибавления единицы является следующее по 
			часовой стрелке число, а результатом вычитания единицы – движение против 
			часовой стрелки. Точно также прибавление или вычитание числа <I>n</I> 
			соответствует <I>n</I> шагам по часовой стрелке или в обратном направлении. 
			В результате может получиться, например, 127 + 1 = –&nbsp;128 в 8-разрядной 
			знаковой арифметике.</P>
		  <P><b>Таким образом, арифметика в ограниченном количестве 
			разрядов несколько отличается от обычной.</b></P>
		  <P></P>
		  <P><B>Пример 8</b>. Пусть <I>k</I> = 4. Требуется сложить 
			числа 5 и 3. </P>
		  <P>5 = <IMG SRC="img/Image1589.gif" WIDTH=53 HEIGHT=28 align="absmiddle">; 
			3 = <IMG SRC="img/Image1590.gif" WIDTH=53 HEIGHT=28 align="absmiddle">.&#9;</P>
		  <P>&nbsp; &nbsp; 0101</P>
		  <P> +&nbsp; <U>0011</U></P>
		  <P> &nbsp; &nbsp; 1000 </P>
		  <P>Если это был беззнаковый тип данных, то результат верный, 
			равный 8. Если этот тип знаковый, то в результате получили отрицательное 
			число, т.к. в знаковом разряде стоит 1. Это произошло потому, что, хотя 
			оба числа и входят в допустимый диапазон, но их сумма, равная 8, уже в 
			него не входит, т.к. допустимый диапазон для такого знакового типа [–2<SUP>3</SUP>,2<SUP>3</SUP>–1]=[–8,7].</P>
		  <P>&nbsp;</P>
		  <P></P>
		  <P><B>Пример 9</b>. <I>k</I> = 4. Сложить числа 13 и 5.      </P>
		  <P>13=8+4+1=<IMG SRC="img/Image1591.gif" WIDTH=52 HEIGHT=28 align="absmiddle">; 
			5=4+1= <IMG SRC="img/Image1592.gif" WIDTH=53 HEIGHT=28 align="absmiddle">.</P>
		  <P> &nbsp; 1101&#9;</P>
		  <P>+<U>0101</u></P>
		  <P>10010 </P>
		  <P>&#9; </P>
		  <P>Если бы не было ограничения на кол-во разрядов и это 
			были беззнаковые числа, то результат был бы верным (=18). Но на 4-х разрядах 
			старшая единица выходит за границу ячейки и “теряется”. В результате получаем 
			13+5=2. Это опять произошло потому, что число сумма не входит в допустимый 
			для данного типа диапазон:</P>
		  <P>[0,2<SUP>4</SUP>–1]=[0,15].</P>
		  <P>Если же рассматривать эти числа, как знаковые, то тогда 
			первое число будет не “13”, а “–3” и тогда всё правильно: –3+5= –2, т.е. 
			арифметически верный результат:</P>
		  <P>&nbsp; 1101</P>
		  <P>&nbsp; 0010</P>
		  <P> <U>+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</u></P>
		  <P>&#9;&nbsp; 0011= –3</P>
		  <P>&nbsp;</P>
		  <P></P>
		  <P><U><B>Итог</b></u>: При выполнении арифметических действий 
			в целочисленной <I>k</I>-разрядной арифметике возможно возникновение следующих 
			ошибок:</P>
		  <P>1) при сложении двух положительных чисел, представленных 
			в знаковом типе данных, можно получить отрицательное число, если в результате 
			сложения в знаковом разряде окажется единица;</P>
		  <P>2) левые цифры результата, выходящие за отведённое количество 
			разрядов, оказываются утерянными.</P>
		  <P></P>
		  <P>В заключение рассмотрим пример вычисления факториала 
			в типе Integer (языка Паскаль). Тип этот знаковый 16-ти разрядный. Вычисления 
			будут происходить правильно вплоть до 7!.</P>
		  <P><img src="img/ii4_3_3.gif" width="354" height="50"></P>
		  <P>&nbsp;</P>
		  <P>Вычислим 8! как 7!x 8:</P>
		  <P>8! = 7!x 8 = 7!x 2<SUP>3</SUP>– это в двоичной арифметике 
			сдвиг на 3 позиции вправо. Если мы сдвинем число (*) на 3 позиции вправо, 
			то получим в знаковом разряде единицу, т.е. отрицательное число. Если 
			перевести его из дополнительного кода, получим:</P>
		  <P> <B>1</B>001 1101 1000 0000 = –25216.</P>
		  <P>Это произошло из-за того, что максимально допустимое 
			число в типе Integer <IMG SRC="img/Image1594.gif" WIDTH=148 HEIGHT=28 align="absmiddle">, 
			а значение 8! выходит за диапазон. Для записи такого числа требуется как 
			минимум 17 разрядов в знаковом типе.</P>
		  <P>Если взять тип longint (32 разряда), то и там возможно 
			получить лишь 12!, а уже 13! выйдет за допустимый диапазон. Причём полученное 
			число введёт в заблуждение, т.к. там в знаковый разряд попадёт 0.</P>
		  <P>&nbsp;</P>
		  <P><U><B>Вывод</b></u>: при написании программы следует 
			внимательно подходить к выбору типа данных, т.к. подобные ошибки компилятор 
			языка не отслеживает.</P>
		  
		  <h3><a name="v" class="anchor"></a>Вопросы и задачи для самопроверки</h3>
		  <OL>
			<LI>Записать беззнаковое число в 8-ми разрядную ячейку памяти: </LI>
			<P> 11, 213; 275.</P>
			<LI>Какое минимальное и максимальное беззнаковое число можно записать 
			  в k- разрядную ячейку памяти при k=2; k=4; k=10.</LI>
			<LI>Какое минимальное и максимальное знаковое число можно записать в k- 
			  разрядную ячейку памяти, если k=2; k=4; k=10.</LI>
			<LI>Записать числа – 105, 27, – 128 как знаковые в 8- разрядной ячейке 
			  памяти.</LI>
			<LI>Записать числа – 8, – 10, в 4-х разрядном дополнительном коде.</LI>
			<LI>Записать число – 254 в дополнительном коде. Какова должна быть минимально 
			  подходящая разрядность ячейки в байтах? </LI>
			<LI>Получить значение десятичного числа по его дополнительному коду:</LI>
			<P> 1) 1110 1100<SUB>2</SUB> </P>
			<P> 2) 1001 0111<SUB>2</SUB> </P>
			<P> 3) 1000 0001<SUB>2 </sub></P>
			<LI>Вычислить в 8-рарядной беззнаковой арифметике:</LI>
			<P> 1) 115+78 </P>
			<P> 2) 92+168</P>
			<LI>Вычислить в 8-разрядной знаковой арифметике:</LI>
		  </OL>
		  <OL>
			<LI>115-49</LI>
			<LI>22-113</LI>
			<LI>127–128 </LI>
			<LI>–127+127 </LI>
			<LI>127+1 </LI>
		  </OL>
		   
		  <P>Результат представить в двоичном и в десятичном виде.</P>
		  
			
			
			
			
			
			</div>
		</div>
	</div>
</div>
	 <!--Меню навигации по Темам-->
	<div aria-label="..." class = "nav-menu">
		<ul class="pager  background-transition-slow" >
			 <li title="Наверх" style = "margin-right:15px;	"><a class = "glyphicon glyphicon-menu-up page-scroll" href="#page-top" ></a></li>
			 <li title="К предыдущей лекции"><a class = "glyphicon glyphicon-menu-left page-scroll" href="lii_3.html" ></a></li>
			 <li title="В содержание"><a class = "glyphicon glyphicon-list-alt" href="lec_index.html" ></a></li>
			 <li title="К следующей лекции"><a class = "glyphicon glyphicon-menu-right page-scroll" href="lii_5.html" ></a></li>
		</ul>
	</div>
 
 
 <!-- jQuery -->
 <script src="../lib/js/jquery.js"></script>

 <!-- Bootstrap Core JavaScript -->
 <script src="../lib/js/bootstrap.min.js"></script>

 <!-- Scrolling Nav JavaScript -->
 <script src="../lib/js/jquery.easing.min.js"></script>
 <script src="../lib/js/scrolling-nav.js"></script>

</body>

</html>