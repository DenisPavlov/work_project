<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="do.sibsutis.ru">

    <title>Лекция 6. Конспект лекций</title>
	
	<link rel="icon" type="image/png" href="../lib/css/favicon.png">
    <!-- Bootstrap Core CSS -->
    <link href="../lib/css/bootstrap.css" rel="stylesheet">
	
    <!-- Custom CSS -->
    <link href="../lib/css/scrolling-nav.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>

<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top" data-spy="scroll" data-target=".navbar-fixed-top" >
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-fixed-top">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <li class="hidden"> <a class="page-scroll" href="#page-top"></a> </li>
	  
	  <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  
      <a class="navbar-brand " href="../index.htm"> 
						<text class = "hidden-xs">Структуры и алгоритмы обработки данных</text> 
						<text class = "visible-xs">САОД</text>
	  </a>
    </div>

    <!-- Collect the nav links, forms, and glyphicon glyphicon-list-alt content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      
	  <!-- <ul class="nav navbar-nav">
		<li><a href="#"></a></li> 
      </ul> -->
	
      <ul class="nav navbar-nav navbar-right">
        <li class="dropdown">
		<button type="button" class="navbar-toggle dropdown-toggle hidden-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false" >
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>	      
		<a class = "dropdown-toggle visible-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Материалы</a>
          <ul class="dropdown-menu">
            <li><a href="../index.htm">Аннотация курса</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="lec_index.htm">Теория</a></li>
            <li><a href="course_work.htm">Контрольная работа</a></li>
            <li><a href="labs.htm">Лабораторные работы</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="lit.htm">Литература</a></li>
          </ul>
 </li>
  </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>


    <!-- Intro Section -->
	<!-- Секция с информацией "Уважаемый слушатель"	 -->
    <div id="intro" class="section content-section ">
        <div class="container">
             <div class="row">
                <div class="col-lg-12">	


<!-- содержание -->	
<div class="page-header">
<h3>6 Методы сортировки последовательностей </h3>
<p><a href="lec6.htm#1" class=punkt>1. Метод прямого слияния</a>
<p><a href="lec6.htm#2" class=punkt>2. Цифровая сортировка</a>
</div>

<h3><a name=1></a>1 Метод прямого слияния</h3><br>

<P ALIGN="JUSTIFY">В основе метода прямого слияния  лежит операция слияния серий. <I>р-серией</I> называется упорядоченная последовательность из <I>р</I> элементов.</P>
<P ALIGN="JUSTIFY">Пусть имеются две упорядоченные серии <I>a</I> и <I>b</I> длины <I>q</I> и <I>r </I>соответственно. Необходимо получить упорядоченную последовательность <I>с</I>, которая состоит из элементов серий <I>a</I> и <I>b</I>. Сначала сравниваем первые элементы последовательностей <I>a </I>и <I>b</I>. Минимальный элемент перемещаем в последовательность <I>с</I>. Повторяем действия до тех пор, пока одна из последовательностей <I>a</I> и <I>b</I> не станет пустой, оставшиеся элементы из другой последовательности переносим в последовательность <I>с</I>. В результате получим (<I>q+r</I>)-серию. </P>
<P><B>Пример. </B>Слить две серии a=(1, 4, 5, 6&#8242;) и b=(2, 3, 6&#8243;, 7, 8)</P>
<P>Условные обозначения |  операция сравнения первых элементов списков.</P>
<br><div align="center"><img src="img_lec/Image38.gif" width="402" height="95"> </div>

<center>Рисунок 20 - Слияние серий</center>
<I><P ALIGN="CENTER"><b>Алгоритм на псевдокоде</b></P>
<P ALIGN="CENTER">Слияние q – серии из списка a с r – серией из списка b, запись результата в очередь c</P>
<P ALIGN="CENTER">Слияние (a, q, b, r, c)</P></I><br>

<P>DO (q &#8800; 0 и r &#8800; 0)</P>
<P>&nbsp;&nbsp;&nbsp;IF (a &#8594; Data &#8804; b &#8594; Data)</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Переместить элемент из списка a в очередь c&gt;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q:=q-1</P>
<P>&nbsp;&nbsp;&nbsp;ELSE</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Переместить элемент из списка b в очередь c&gt;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r:=r-1</P>
<P>&nbsp;&nbsp;&nbsp;FI</P>
<P>OD</P>
<P>DO (q &gt; 0)</P>
<P>&nbsp;&nbsp;&nbsp;&lt;переместить элемент из списка a в очередь c&gt;</P>
<P>&nbsp;&nbsp;&nbsp;q:=q-1</P>
<P>OD</P>
<P>DO (r &gt; 0)</P>
<P>&nbsp;&nbsp;&nbsp;&lt;Переместить элемент из списка b в очередь c&gt;</P>
<P>&nbsp;&nbsp;&nbsp;r:=r-1</P>
<P>OD</P>
<br><P>Для алгоритма слияния серий с длинами q и r необходимое количество сравнений и перемещений оценивается следующим образом</P>
<P ALIGN="CENTER">min (<I>q, r</I>) &#8804; C &#8804; <I>q+r-1</I>, M=<I>q+r</I></P>
<P ALIGN="JUSTIFY">Пусть длина списка S равна степени двойки, т.е. 2<SUP>k</SUP>, для некоторого натурального <I>k</I>. Разобьем последовательность S на два списка <I>a</I> и <I>b</I>, записывая поочередно элементы S в списки <I>а</I> и <I>b</I>. Сливаем списки a и b с образованием двойных серий, то есть одиночные элементы сливаются в упорядоченные пары, которые записываются попеременно в очереди c<SUB>0</SUB> и c<SUB>1</SUB>. Переписываем очередь <I>c<SUB>0</SUB></I> в список <I>a</I>, очередь <I>c<SUB>1</SUB></I> – в список <I>b</I>. Вновь сливаем <I>a</I> и <I>b</I> с образованием серий длины 4 и т. д. На каждом итерации размер серий увеличивается вдвое. Сортировка заканчивается, когда длина серии превысит общее количество элементов в обоих списках. Если длина списка S не является степенью двойки, то некоторые серии в процессе сортировки могут быть короче.</P>
<P><B>Пример. </B>Отсортировать слово методом прямого слияния.</P>
<div align="center"><img src="img_lec/Image39.gif" width="638" height="415"> </div>
<br><center>Рисунок 21 - Метод прямого слияния</center><br>
<P ALIGN="JUSTIFY">Схематически начальное расщепление  последовательности <I>S</I> на списки <I>a</I> и <I>b </I>можно изобразить следующим образом. Ниже приведен алгоритм расщепление на псевдокоде при условии, что список S не пуст.</P>
<div align="center"><img src="img_lec/Image40.gif" width="647" height="181"> </div>
<br><center>Рисунок 22 - Начальное расщепление</center><br>
<P ALIGN="CENTER"><i>Расщепление (S, a, b, n)</i></P><br>
<P>Обозначим </P>
<P>&nbsp;&nbsp;&nbsp;&#9;n - количество элементов в S</P>
<P>&nbsp;&nbsp;&nbsp;&#9;k, p - рабочие указатели </P><br>

<P>&#9;a:=S, b:=S &#8594; Next, n:=1</P>
<P>k:=a, p:=b </P>
<P>&#9;DO (p &#8800; NIL)</P>
<P>&nbsp;&nbsp;&nbsp;&#9;&#9;n:=n+1</P>
<P>&nbsp;&nbsp;&nbsp;&#9;&#9;k &#8594; next:=p &#8594; next</P>
<P>&nbsp;&nbsp;&nbsp;&#9;&#9;k:=p</P>
<P>&nbsp;&nbsp;&nbsp;&#9;&#9;p:=p &#8594; next</P>
<P>&#9;OD</P>
<br><P ALIGN="CENTER"><B><I>Алгоритм на псевдокоде</i></b></P>
<br><P>Обозначим&#9;&#9;n – количество элементов в S</P>
<P>&nbsp;&nbsp;&nbsp;&#9;&#9;&#9;a, b – рабочие списки</P>
<P>&nbsp;&nbsp;&nbsp;&#9;&#9;c=(c<SUB>0</SUB>, c<SUB>1</SUB>) – массив из двух очередей</P>
<P>&nbsp;&nbsp;&nbsp;&#9;&#9;&#9;p – предполагаемый размер серии</P>
<P>&nbsp;&nbsp;&nbsp;&#9;&#9;&#9;q – фактический размер серии в списке a</P>
<P>&nbsp;&nbsp;&nbsp;&#9;&#9;&#9;r – фактический размер серии в списке b </P>
<P>&nbsp;&nbsp;&nbsp;&#9;&#9;&#9;m – текущее количество элементов в списках a и b</P>
<P>&nbsp;&nbsp;&nbsp;&#9;&#9;&#9;i – номер активной очереди </P>
<br><P>&#9;&lt;Расщепление (S, a, b, n)&gt;</P>
<P>&#9;p:=<B> </B>1</P>
<P>DO (p &lt; n)</P>
<P>&nbsp;&nbsp;&nbsp;&lt;инициализация очередей c<SUB>0</SUB>, c<SUB>1</SUB>&gt;  </P>
<P>&nbsp;&nbsp;&nbsp;i:=0, m:=n</P>
<P>&nbsp;&nbsp;&nbsp;DO (m &gt; 0)  </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF (m &#8805; p) q:=p ELSE q:=m FI</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m:= m – q</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF (m &#8805; p) r:=p ELSE r:=m FI </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m:= m – r  </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;слияние(a, q, b, r, c<SUB>i </SUB>)&gt;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i:=1–i</P>
<P>&nbsp;&nbsp;&nbsp;OD </P>
<P>&nbsp;&nbsp;&nbsp;a:=c<SUB>0</SUB>.Head, b:=c<SUB>1</SUB>.Head </P>
<P>&nbsp;&nbsp;&nbsp;p:=2p </P>
<P>OD</P>
<P>c<SUB>0</SUB>.Tail &#8594; next:=NIL</P>
<P>S:=c<SUB>0</SUB>.Head</P><br>
<P ALIGN="JUSTIFY">При инициализации очереди обнуляются указатели, указывающие на начало и на конец очереди, т.е. очередь становится пустой.</P>
<P ALIGN="JUSTIFY">Трудоёмкость метода<B> </B>прямого слияния определяется сложностью операции слияния серий. На каждой итерации происходит ровно n перемещений элементов списка и не более <I>n</I> сравнений. Как нетрудно видеть, количество итераций равно<B><I> <IMG SRC="img_lec/Image41.gif" WIDTH=48 HEIGHT=24 align="absmiddle"></I></B>. Тогда</P>
<P ALIGN="CENTER">C &lt; <I>n</I><IMG SRC="img_lec/Image41.gif" WIDTH="48" HEIGHT="24" align="absmiddle">, M=<I>n</I><IMG SRC="img_lec/Image41.gif" WIDTH=48 HEIGHT=24 align="absmiddle">+<I>n.</I></P>
<P ALIGN="JUSTIFY">Дополнительные <I>n</I> перемещений происходят во время начального расщепления исходного списка. Асимптотические оценки для М и С имеют следующий вид</P>
<P ALIGN="CENTER">С=О(<I>n</I> log <I>n</I>), М=О(<I>n</I> log <I>n</I>) при <I>n &#8594; &#8734;</I>.</P>
<P ALIGN="JUSTIFY">Метод обеспечивает устойчивую сортировку.<B> </B>При реализации для массивов, метод требует наличия второго вспомогательного массива, равного по размеру исходному массиву. При реализации со списками дополнительной памяти не требуется.</P>
<br><h3><a name=2></a>2 Цифровая сортировка</h3><br>
<P ALIGN="JUSTIFY">Другим методом сортировки последовательностей является цифровая сортировка. Пусть дана последовательность из S чисел, представленных в <I>m</I> – ичной системе счисления. Каждое число состоит из L цифр d<SUB>1</SUB>d<SUB>2</SUB>…d<SUB>L</SUB>, 0 &#8804; d<SUB>i</SUB> &#8804; <I>m</I> – 1, i=1..L. Сначала числа из списка S распределяются по <I>m</I> очередям, причём номер очереди определяется последней цифрой каждого числа. Затем полученные очереди соединяются в список, для которого все действия повторяются, но распределение по очередям производится в соответствии со следующей цифрой и т.д.</P>
<P ALIGN="JUSTIFY"><B>Пример.</B> Отсортировать последовательность  31  03&#8242;  20  02  03&#8243;  33  30  21 методом цифровой сортировки. Числа представлены в четверичной системе счисления.</P></FONT>
<div align="center"><img src="img_lec/Image42.gif" width="371" height="252"> </div>
<br><center>Рисунок 23 - Цифровая сортировка</center><br>
<i><p><b>Алгоритм на псевдокоде</b></P>
<P ALIGN="CENTER">Цифровая сортировка</P></I><br>
<P>DO (j=L, L–1, … , 1)</P>
<P>&nbsp;&nbsp;&nbsp;&lt;инициализация очередей Q&gt;</P>
<P>&nbsp;&nbsp;&nbsp;&lt;расстановка элементов из списка S в очереди Q по j – ой цифре &gt;</P>
<P>&nbsp;&nbsp;&nbsp;&lt;соединение очередей Q в список S &gt;</P>
<P>OD</P>
<br><P ALIGN="JUSTIFY">Цифровой метод может успешно использоваться не только для сортировки чисел, но и для сортировки любой информации, представленной в памяти компьютера. Необходимо лишь рассматривать каждый байт ключа сортировки как цифру, принимающую значения от 0 до 255. Тогда для сортировки потребуется <I>m</I>=256 очередей. Для выделения каждого байта ключа сортировки можно использовать массив Digit, наложенный в памяти компьютера на поле элемента последовательности, по которому происходит сортировка. Приведем более детальный алгоритм цифровой сортировки.</P>
<P ALIGN="JUSTIFY"></P>
<br><I><P ALIGN="CENTER"><B>Алгоритм на псевдокоде</B></P>
<P ALIGN="CENTER">Цифровая сортировка</P></I><br>
<P>DO (j=L, L-1, … 1)</P>
<P>&nbsp;&nbsp;&nbsp;DO (i=0, 1, … 255) </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q<SUB>i</SUB>.Tail:=@ Q<SUB>i</SUB>.Head </P>
<P>&nbsp;&nbsp;&nbsp;OD</P>
<P>&nbsp;&nbsp;&nbsp;p:=S</P>
<P>&nbsp;&nbsp;&nbsp;DO (p &#8800; NIL)</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d:=p &#8594; Digit[j]</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q<SUB>d</SUB>.Tail &#8594; Next:=p</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q<SUB>d</SUB>.Tail:=p</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p:=p &#8594; Next</P>
<P>&nbsp;&nbsp;&nbsp;OD</P>
<P>&nbsp;&nbsp;&nbsp;p:=@ S</P>
<P>&nbsp;&nbsp;&nbsp;DO (i=0, 1, … 255)</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF (Q<SUB>i</SUB>.Tail &#8800; @ Q<SUB>i</SUB>.Head)</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p &#8594; Next:=Q<SUB>i</SUB>.Head</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p:=Q<SUB>i</SUB>.Tail</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FI</P>
<P>&nbsp;&nbsp;&nbsp;OD</P>
<P>&nbsp;&nbsp;&nbsp;p &#8594; Next:=NIL</P>
<P>OD</P>
<br><P ALIGN="JUSTIFY">Для цифровой сортировки М&lt;const L(<I>m+n</I>). При фиксированных <I>m</I> и L М=O(<I>n</I>) при <I>n &#8594; &#8734;</I>, что значительно быстрее остальных рассмотренных методов. Однако если длина чисел L велика, то метод может проигрывать обычным методам сортировки. Кроме того, Метод применим только, если задача сортировки сводится к задаче упорядочивания чисел, что не всегда возможно.</P>
<P ALIGN="JUSTIFY">Метод обеспечивает устойчивую сортировку. Чтобы изменить направление сортировки на обратное, очереди нужно присоединять в обратном порядке. </P>
<br><h3>Контрольные вопросы</h3>
<OL>
<P ALIGN="JUSTIFY"><LI>В чем смысл операции слияния серий?</LI></P>
<P ALIGN="JUSTIFY"><LI>Какова сложность метода прямого слияния?</LI></P>
<P ALIGN="JUSTIFY"><LI>В чем основная идея метода цифровой сортировки?</LI></P>
<P ALIGN="JUSTIFY"><LI>Является ли метод цифровой сортировки устойчивым?</LI></P>
<P ALIGN="JUSTIFY"><LI>Можно ли применять методы сортировки последовательностей для упорядочивания массивов?</LI></P></OL>


<!-- конец содержания-->	
				
				</div>
			</div>
			
            </div>
        </div>
    </div>
	
	<!--Меню навигации по лекциям -->	
	<div aria-label="..." class = "nav-menu">
	  <ul class="pager  background-transition-slow" >
		 <li title="Наверх" style = "margin-right:15px;	"><a class = "glyphicon glyphicon-menu-up page-scroll" href="#page-top" ></a></li>
		 <li title="К предыдущей лекции"><a class = "glyphicon glyphicon-menu-left page-scroll" href="lec5.htm" ></a></li>
		 <li title="В содержание"><a class = "glyphicon glyphicon-list-alt" href="lec_index.htm" ></a></li>
		 <li title="К следующей лекции"><a class = "glyphicon glyphicon-menu-right page-scroll" href="lec7.htm" ></a></li>
	  </ul>
	</div>
	<!---->
	
	</div>
    <!-- jQuery -->
    <script src="../lib/js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../lib/js/bootstrap.min.js"></script>

    <!-- Scrolling Nav JavaScript -->
    <script src="../lib/js/jquery.easing.min.js"></script>
    <script src="../lib/js/scrolling-nav.js"></script>

</body>

</html>
