<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="do.sibsutis.ru">

    <title>Лекция 1. Конспект лекций</title>
	
	<link rel="icon" type="image/png" href="../lib/css/favicon.png">
    <!-- Bootstrap Core CSS -->
    <link href="../lib/css/bootstrap.css" rel="stylesheet">
	
    <!-- Custom CSS -->
    <link href="../lib/css/scrolling-nav.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>

<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top" data-spy="scroll" data-target=".navbar-fixed-top" >
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-fixed-top">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <li class="hidden"> <a class="page-scroll" href="#page-top"></a> </li>
	  
	  <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  
      <a class="navbar-brand " href="../index.htm"> 
   <text class = "hidden-xs">Структуры и алгоритмы обработки данных </text> 
   <text class = "visible-xs">САОД</text>
	  </a>
    </div>

    <!-- Collect the nav links, forms, and glyphicon glyphicon-list-alt content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      
	  <!-- <ul class="nav navbar-nav">
		<li><a href="#"></a></li> 
      </ul> -->
	
      <ul class="nav navbar-nav navbar-right">
        <li class="dropdown">
		<button type="button" class="navbar-toggle dropdown-toggle hidden-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false" >
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>	      
		<a class = "dropdown-toggle visible-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Материалы</a>
          <ul class="dropdown-menu">
            <li><a href="../index.htm">Аннотация курса</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="lec_index.htm">Теория</a></li>
            <li><a href="course_work.htm">Контрольная работа</a></li>
            <li><a href="labs.htm">Лабораторные работы</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="lit.htm">Литература</a></li>
          </ul>
 </li>
  </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>


    <!-- Intro Section -->
	<!-- Секция с информацией "Уважаемый слушатель"	 -->
    <div id="intro" class="section content-section ">
        <div class="container">
             <div class="row">
                <div class="col-lg-12">	


<!-- содержание -->	
<div class="page-header">				
<h3>1 Необходимые понятия и определения</h3>
<p><a href="lec1.htm#1" class=punkt>1. Основные структуры данных</a>
<p><A HREF="lec1.htm#2"class=punkt>2. Задача сортировки массивов</a>
 <p><A HREF="lec1.htm#3" class=punkt>3. Трудоемкость методов сортировки массивов</a>
 <p><A HREF="lec1.htm#4" class=punkt>4. Задача сортировки последовательностей</a>
<p><A HREF="lec1.htm#5" class=punkt> 5. Теорема о сложности сортировки</a>
<p><A HREF="lec1.htm#6" class=punkt>6. Задача поиска элементов с заданным ключом</a>
</div>

<h3 ><a name="1"></a>1 Основные структуры данных</h3>

<p></I><P ALIGN="JUSTIFY">Любая программа в процессе работы обрабатывает некоторые данные. По способу представления в памяти компьютера данные можно разделить на две группы: статические и динамические. Статические данные имеют фиксированную структуру, поэтому размер выделенной для них памяти постоянен. Динамические данные изменяют свою структуру в процессе работы программы, при этом объём памяти изменяется. Основные структуры данных представлены в следующей таблице.</P>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=488>
<caption>Таблица 1 - Различные типы данных</caption>
<TR><TD WIDTH="36%" VALIGN="MIDDLE" ROWSPAN=8 HEIGHT=19>
<P>Статические</TD>
<TD WIDTH="36%" VALIGN="MIDDLE" ROWSPAN=5 HEIGHT=19>
<P>Простые</TD>
<TD WIDTH="27%" VALIGN="MIDDLE" HEIGHT=19>
<P>Перечислимые</TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="MIDDLE" HEIGHT=18>
<P>Целые</TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="MIDDLE" HEIGHT=21>
<P>Вещественные</TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="MIDDLE" HEIGHT=23>
<P>Логические </TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="MIDDLE" HEIGHT=12>
<P>Символьные</TD>
</TR>
<TR><TD WIDTH="36%" VALIGN="MIDDLE" ROWSPAN=3 HEIGHT=25>
<P>Структурированные</TD>
<TD WIDTH="27%" VALIGN="TOP" HEIGHT=25>
<P>Массивы</TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP" HEIGHT=22>
<P>Записи</TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP" HEIGHT=22>
<P>Объединения</TD>
</TR>
<TR><TD WIDTH="36%" VALIGN="MIDDLE" ROWSPAN=4 HEIGHT=26>
<P>Динамические</TD>
<TD WIDTH="36%" VALIGN="MIDDLE" ROWSPAN=2 HEIGHT=26>
<P>Списки</TD>
<TD WIDTH="27%" VALIGN="TOP" HEIGHT=26>
<P>Стек</TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP" HEIGHT=23>
<P>Очередь</TD>
</TR>
<TR><TD WIDTH="36%" VALIGN="MIDDLE" ROWSPAN=2 HEIGHT=24>
<P>Деревья</TD>
<TD WIDTH="27%" VALIGN="TOP" HEIGHT=24>
<P>АВЛ-деревья</TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP" HEIGHT=25>
<P>Б-деревья</TD>
</TR>
</TABLE>
</CENTER></P>

<p>&nbsp;
<P ALIGN="JUSTIFY">Основной характеристикой данных в программировании является тип данных. Любая константа, переменная, выражение, функция всегда относятся к определенному типу. Тип характеризует множество значений, которые может принимать переменная. К простым типам языка программирования относятся целые, вещественные, логические, символьные. Целые типы в языках программирования различаются количеством байт, отведённых в памяти (диапазоном значений) и наличием знака. Вещественные типы характеризуются точностью представления числа. Перечислимые типы образуются в процессе перечисления всех возможных значений. Логический тип является частным случаем перечислимого типа с двумя возможными значениями ИСТИНА и ЛОЖЬ.</P>
<P ALIGN="JUSTIFY">Структурированные (составные) типы отличаются от простых тем, что состоят из набора компонент одинакового или разного типа. К структурированным типам относят массивы, записи (структуры), объединения (записи с вариантами). </P>
<P ALIGN="JUSTIFY">Массивы – это наиболее известная и распространённая структура данных. Массив представляет собой фиксированное количество элементов одного типа. Всем элементам присваивается одно имя, а к отдельному  элементу обращаются по его номеру (индексу). Тип элементов массива может быть любым, но тип индексов должен быть скалярным. Массив – структура данных со случайным (прямым) доступом, т.е. в любой момент времени доступен любой элемент массива, при этом индекс элемента можно вычислять. Обычный способ работы с массивом – выбор определённых элементов и их изменение. Также часто используется перебор элементов в цикле. В памяти элементы массива располагаются последовательно, без разрывов, по возрастанию адресов памяти.</P>
<P ALIGN="JUSTIFY">Другой вид структурированных типов – запись состоит из фиксированного<U> </U>числа компонент называемых <B>полями</B>, которые в отличие от элементов массива могут быть разных типов. <B>Запись</B> также является структурой данных со случайным доступом. </P>
<P ALIGN="JUSTIFY">Объединения или (записи с вариантами) используются для размещения в одной и той же области памяти данных различного типа. В один и тот же момент времени в памяти находятся данные только одного типа.</P>
<P ALIGN="JUSTIFY">Динамические структуры данных позволяют работать с большими объемами данных. Наиболее используемые динамические структуры данных – списки и деревья.</P>

<br><h3 ><a name="2"></a>2 Задача сортировки массивов</h3><br>
<P ALIGN="JUSTIFY">Пусть дан массив А=(<I>а<SUB>1</SUB>, а<SUB>2</SUB>, …, а<SUB>n</SUB></I>) и для всех его элементов определены операции отношения: меньше, больше, 
равно (&lt;, &gt;, =). Необходимо отсортировать массив, т.е. переставить элементы массива А таким образом, что выполняется одно из следующих неравенств:</P>
<i><P ALIGN="CENTER">a<SUB>1</SUB> &#8804; а<SUB>2</SUB> &#8804; а<SUB>3</SUB> &#8804; … &#8804; а<SUB>n</SUB></P>
<P ALIGN="CENTER">a<SUB>1</SUB> &#8805; a<SUB>2</SUB> &#8805; a<SUB>3</SUB> &#8805;  ... &#8805; a<SUB>n</SUB></P></i>
<P ALIGN="JUSTIFY">Если выполняется первое неравенство, то массив сортируется по возрастанию и такой порядок элементов будем называть <I>прямым</I>. Если выполняется второе неравенство, то массив отсортирован по убыванию и такой порядок элементов будем называть <I>обратным</I>. В дальнейшем, если не оговорено особо, используется прямой порядок сортировки. </P>
<P ALIGN="JUSTIFY">При сортировке массивов элементов со сложной структурой возникает задача определить отношение порядка между элементами. Та часть информации, которая учитывается при определении отношения порядка называется <I>ключом</I><B> </B><I>сортировки.</I></P>
<P ALIGN="JUSTIFY">Сортировка называется <I>устойчивой</I>, если после её проведения в массиве не меняется относительный порядок элементов с одинаковыми ключами.</P>
<P ALIGN="JUSTIFY">Для проверки правильности сортировки массива могут использоваться следующие приемы. Вычисление контрольной суммы элементов массива до и после сортировки дает возможность проверить потерю элементов массива во время процесса сортировки. Определение количества серий элементов массива, т.е. неубывающих последовательностей из элементов массива, позволяет проверить правильность упорядочивания массива, поскольку массив, отсортированный по возрастанию, состоит из одной серии, а в массиве, отсортированном по убыванию, количество серий равно количеству элементов в массиве.</P>
<P ALIGN="JUSTIFY">&nbsp;</P>

<br><h3 ><a name="3"></a>3 Трудоемкость методов сортировки массивов</h3><br>

<P ALIGN="JUSTIFY">Существует много способов или методов сортировки массивов. Для того, чтобы оценить насколько один метод сортировки лучше другого необходимо каким-то образом оценивать эффективность метода сортировки. Естественно отличать методы сортировки по времени, затрачиваемому на реализацию сортировки. Для сортировок основными считаются две операции: операция сравнения элементов и операция пересылки элемента. Будем считать, что в единицу времени выполняется одна операция сравнения или пересылки. Таким образом, время  или трудоемкость метода имеет две составляющие М и С, где</P>
<P ALIGN="JUSTIFY">M – количество операций пересылки.</P>
<P ALIGN="JUSTIFY">C– количество операций сравнения.</P>
<P ALIGN="JUSTIFY">Нетрудно видеть, что M и C – зависят от количества элементов в массиве, т.е. являются функциями от длины массива. Часто бывает трудно определить точное выражение для трудоемкости алгоритма. В этом случае пользуются асимптотической оценкой времени работы. </P>
<P ALIGN="JUSTIFY">Будем говорить, что функция <I>g(x)</I> <I>асимптотически доминирует</I> на <I>f(</I>x) или <I>g(x)=O(f(x)),</I> если |<I>g(x)|&#8804;const|f(x)|</I> при <I>x&#8594; &#8734;</I>. В дальнейшем будем рассматривать асимптотическое поведение величин М и С в зависимости от числа элементов в массиве <I>n</I>, при <I>n</I>&#8594; &#8734;.</P>
<P>Для функций <I>f, f<SUB>1</SUB>,f<SUB>2</SUB></I> и константы <I>k</I> справедливы свойства:</P>

<OL>
<LI><I>f = O(f)</i></LI>
<LI><i>O(k*f) = O(f)</i></LI>
<LI><i>O(f<SUB>1</SUB>+f<SUB>2</SUB>) = O(f<SUB>1</SUB>) +O(f<SUB>2</SUB>)</i></LI>
</OL>

<P><B>Пример. &#9;</B>T = 10<I>n</I> + 20 </P><DIR>
<DIR>

<P>T = O(10<I>n</I>+20) = O(10<I>n</I>) + O(20) = O(<I>n</I>) +O(1) = O(<I>n</I>), при <I>n</I>&#8594; &#8734;.</P></DIR>
</DIR>

<P>Приведем ряд доминирования основных функций</P>
<P ALIGN="CENTER">O(1)&lt;O(log <I>n</I>)&lt;O(<I>n</I>)&lt;O(<I>n</I> log <I>n</I>)&lt;O(<I>n<SUP>a</SUP></I>)&lt;O(<I>a<SUP>n</SUP></I>)&lt;O(<I>n</I>!)&lt;O(<I>n<SUP>n</SUP></I>), при <I>n</I>&#8594; &#8734;, <I>a</I>&gt;1</P>
<P ALIGN="JUSTIFY">Поскольку для различных массивов один и тот же метод сортировки может иметь различную трудоемкость, то необходимо знать в каких пределах могут изменяться величины характеризующие трудоемкость, т.е. определить минимальное и максимальное значения трудоемкости и массивы, на которых достигаются эти значения, а также средние значения величин М и С.</P>

<br><h3 ><a name="4"></a>4 Задача сортировки последовательностей</h3><br>
<P ALIGN="JUSTIFY">Пусть дана последовательность S=S<SUB>1</SUB>S<SUB>2</SUB> …S<SUB>n </SUB>, т.е. совокупность данных с последовательным доступом к элементам. Примерами такой последовательности могут служить файл на магнитной ленте, линейный список:</P>
<P ALIGN="JUSTIFY">Необходимо переставить элементы последовательности так, чтобы выполнялись неравенства:S<SUB>1</SUB>&#8804; S<SUB>2</SUB> &#8804; … &#8804; S<SUB>n </SUB>Последовательный доступ означает, что любой элемент списка может быть получен только путём просмотра предыдущих элементов, причём просмотр возможен только в одном направлении. Это является существенным ограничением по сравнению с массивом, где можно было обратиться к любому элементу массиву, используя индекс. Поэтому методы сортировки, разработанные специально для массивов, не годятся для последовательностей, в то время как методы сортировки последовательностей используются и для сортировки массивов. Трудоемкость методов сортировки последовательностей измеряется количеством операций, затрачиваемых на сортировку. Характерными операциями при сортировке последовательностей являются операция сравнения элементов и операция пересылки элемента одной последовательности в другую. Как и прежде будем обозначать количества операций сравнения и пересылки С и М соответственно.</P>
<br><h3 ><a name="5"></a>5 Теорема о сложности сортировки</h3><br>
<P ALIGN="JUSTIFY">При изучении различных методов сортировок возникает закономерный вопрос о построении метода сортировки с минимально возможной трудоемкостью. Следующая теорема устанавливает нижнюю границу трудоемкости для сортировки массива из <I>n </I>элементов.</P>
<P ALIGN="JUSTIFY"><U>Теорема</U>.<I> Если все перестановки из n элементов равновероятны, то любое дерево решений, сортирующее последовательность из n элементов имеет среднюю высоту не менее log(n!).</I></P>
<P ALIGN="JUSTIFY">Приведем нестрогое доказательство. Рассмотрим дерево решений для трех элементов a, b, c.</P><br>
<div align="center"><img src="img_lec/Image1.gif"  width="528" height="185"></div>
<br><center><FONT SIZE=2>Рисунок 1 - Дерево решений для 6 элементов</font></center><br>

<P ALIGN="JUSTIFY">Все возможные перестановки – это листья дерева (6 вариантов). Чтобы получить конкретную перестановку нужно сделать два или три сравнения. Оценим среднее количество сравнений, необходимых для упорядочивания массива или среднюю длину пути от корня дерева до листьев. Для этого посчитаем сумму длин всевозможных путей от корня до листьев (длина внешнего пути двоичного дерева) и поделим ее на количество листьев С<SUB>ср</SUB>= (2+3+3+3+3+2)/6=2,6.</P>
<P ALIGN="JUSTIFY">Из теории графов известно, что длина внешнего пути двоичного дерева с <I>m</I> листьями D(<I>m</I>)&#8805;<I>m</I> log <I>m</I>. Поскольку в общем случае на дереве имеется <I>n</I>! листьев. Тогда С<SUB>ср</SUB>&#8805;<I>n</I>! log(<I>n</I>!)/<I>n</I>!=lоg <I>n</I>! &gt;<I> n</I> log <I>n–n</I> log <I>e. </I>Последнее неравенство является известной нижней оценкой для значения факториала. Таким образом, не существует алгоритма сортировки <I>n</I> элементов, использующего в среднем меньше чем (<I>n</I> log <I>n</I> – log <I>e</I>) операций сравнения. Класс сложности <I>n</I> log <I>n</I> является предельно достижимым для алгоритмов сортировки с использованием операций сравнения. Что касается количества пересылок, то если мы определим требуемую перестановку, и имеем память для второй копии массива, то достаточно сделать <I>n</I> пересылок. На сегодняшний день алгоритм, требующий <I>n</I>log<I>n </I>сравнений и <I>n </I>пересылок, неизвестен.</P>
<br><h3 ><a name="6"></a>6 Задача поиска элементов с заданным ключом</h3><br>
<P ALIGN="JUSTIFY">Пусть имеется массив A = (<I>a<SUB>1</SUB>, a<SUB>2</SUB>, … a<SUB>n</SUB></I>) и задан ключ поиска X. Необходимо найти элемент (элементы) массива с ключом X, или определить, что элемента с заданным ключом в массиве нет. Если массив не упорядочен, то единственный путь поиска – просмотр всех элементов массива (линейный поиск) до тех пор, пока не будет найден этот элемент, или просмотрен весь массив. Трудоёмкость поиска в этом случае равна O(<I>n</I>), <I>n</I>&#8594; &#8734;. Более эффективные алгоритмы поиска можно построить, если предполагать, что массив отсортирован, т.е. <I>a<SUB>1</SUB>&#8804; a<SUB>2</SUB> &#8804; a<SUB>3</SUB> &#8804; … &#8804; a<SUB>n</SUB></I>. Трудоемкость метода поиска будем оценивать по количеству сравнений, требуемых для поиска нужного элемента, при этом нас интересует только асимптотическая оценка трудоемкости.</P>
<br><h3 >Контрольные вопросы</h3><br>

<ol>
<P ALIGN="JUSTIFY"><LI>Перечислите основные типы данных</LI></P>
<P ALIGN="JUSTIFY"><LI>Сформулируйте задачу сортировки массивов.</LI></P>
<P ALIGN="JUSTIFY"><LI>Как измеряется трудоемкость сортировки массивов?</LI></P>
<P ALIGN="JUSTIFY"><LI>Сформулируйте задачу сортировки последовательностей</LI></P>
<P ALIGN="JUSTIFY"><LI>Сформулируйте задачу поиска заданного элемента в массиве</LI></P>
<P ALIGN="JUSTIFY"><LI>Назовите предельную сложность для задачи сортировки массивов.</LI></P>
</OL>

				</div>
			</div>
			
            </div>
        </div>
    </div>
	
	<!--Меню навигации по лекциям -->	
	<div aria-label="..." class = "nav-menu">
	  <ul class="pager  background-transition-slow" >
		 <li title="Наверх" style = "margin-right:15px;	"><a class = "glyphicon glyphicon-menu-up page-scroll" href="#page-top" ></a></li>
		 <li title="К предыдущей лекции"><a class = "glyphicon glyphicon-menu-left page-scroll" href="lec_index.htm" ></a></li>
		 <li title="В содержание"><a class = "glyphicon glyphicon-list-alt" href="lec_index.htm" ></a></li>
		 <li title="К следующей лекции"><a class = "glyphicon glyphicon-menu-right page-scroll" href="lec2.htm" ></a></li>
	  </ul>
	</div>
	<!---->
	
	</div>
    <!-- jQuery -->
    <script src="../lib/js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../lib/js/bootstrap.min.js"></script>

    <!-- Scrolling Nav JavaScript -->
    <script src="../lib/js/jquery.easing.min.js"></script>
    <script src="../lib/js/scrolling-nav.js"></script>

</body>

</html>
